<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python列表元组字典</title>
      <link href="2021/01/14/python-lie-biao-yuan-zu-zi-dian/"/>
      <url>2021/01/14/python-lie-biao-yuan-zu-zi-dian/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><strong>“列表”是一个值</strong>，它包含多个字构成的序列。<br><strong>术语“列表值”指的是列表本身</strong>（它作为一个值，可以保存在变量中，或传递给函数，像所有其他值一样），而不是指列表值之内的那些值</p><p>列表值看起来像这样：[‘cat’, ‘bat’, ‘rat’, ‘elephant’]    方框</p><ul><li><p>用<strong>下标</strong>取得列表中的单个值假定列表[‘cat’, ‘bat’, ‘rat’, ‘elephant’]  0 1 2 3</p></li><li><p>可以是二维的</p></li><li><p>负数下标，。整数值−1 指的是列表中的最后一个下标，−2 指的是列表中倒数第二个下标，以此类推</p></li><li><p>利用切片取得子列表，spam[1:4]是一个列表和切片（两个整数）。</p><blockquote><p>在一个切片中，第一个整数是切片开始处的下标。<strong>第二个整数是切片结束处的下标</strong>。切片向上增长，直至第二个下标的值，<strong>但不包括它</strong>。</p><p>作为快捷方法，你可以省略切片中冒号两边的一个下标或两个下标。省略第一个下标相当于使用0，或列表的开始。省略第二个下标相当于使用列表的长度，意味着分片直至列表的末尾。</p></blockquote></li><li><p>用len()取得列表的长度</p></li><li><p>用下标改变列表中的值 spam[1]=’cat’</p></li><li><p>列表连接和列表复制</p><blockquote><p>+操作符可以连接两个列表，得到一个新列表<br>*操作符可以用于一个列表和一个整数，实现列表的复制</p></blockquote></li><li><p>用del 语句从列表中删除值  </p><blockquote><p>del spam[2]<br>del 语句也可用于一个简单变量，删除它，作用就像是“取消赋值”语句。如果在删除之后试图使用该变量，就会遇到NameError 错误，因为该变量已不再存在。<br><strong>del 语句几乎总是用于删除列表中的值。</strong></p></blockquote></li><li><p>in 和not in 操作符   cat in [‘cat’,’dog’]</p></li><li><p>多重赋值技巧</p></li></ul><img src="/2021/01/14/python-lie-biao-yuan-zu-zi-dian/image-20210113224149880.png" class="" title="image-20210113224149880"><ul><li><p>用index()方法在列表中查找值</p><blockquote><p>spam.index(‘hello’)<br>列表值有一个index()方法，可以传入一个值，如果该值存在于列表中，就返回它的下标。如果该值不在列表中，Python 就报ValueError。</p></blockquote></li><li><p>用append()和insert()方法在列表中添加值</p><blockquote><p>spam.append(‘moose’)<br>spam.insert(1, ‘chicken’) 第一个参数是Index</p></blockquote></li><li><p>用remove()方法从列表中删除值</p><blockquote><p>spam.remove(‘bat’)</p></blockquote></li><li><p>用sort()方法将列表中的值排序</p><blockquote><p>不能对既有数字又有字符串值的列表排序，因为Python 不知道如何比较它们。<br>spam = [1, 3, 2, 4, ‘Alice’, ‘Bob’]<br>sort()方法对字符串排序时，使用“ASCII 字符顺序”，而不是实际的字典顺序。这意味着大写字母排在小写字母之前。因此在排序时，小写的a 在大写的Z 之后。</p></blockquote></li></ul><img src="/2021/01/14/python-lie-biao-yuan-zu-zi-dian/image-20210113223944152.png" class="" title="image-20210113223944152"><ul><li><p>对列表的许多操作，也可以作用于<strong>字符串</strong>：按下标取值、切片、用于for 循环、用于len()，以及用于in 和not in 操作符。</p></li><li><p><strong>列表和字符串在一个重要的方面是不同的</strong>。<strong>列表是“可变的”数据类型</strong>，它的值可以添加、删除或改变。但是，<strong>字符串是“不可变的”</strong>，它不能被更改。</p></li></ul><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>除了两个方面，“元组”数据类型几乎与列表数据类型一样。</p><ul><li>首先，元组输入Python 编程快速上手——让繁琐工作自动化时用圆括号()，而不是用方括号[]。</li><li>元组像字符串一样，是不可变的。元组不能让它们的值被修改、添加或删除。</li></ul><p><strong>如果元组中只有一个值</strong>，你可以在括号内该值的后面跟上一个逗号，表明这种情况。否则，Python 将认为，你只是在一个普通括号内输入了一个值。逗号告诉Python，这是一个元组</p><h5 id="用list-和tuple-函数来转换类型"><a href="#用list-和tuple-函数来转换类型" class="headerlink" title="用list()和tuple()函数来转换类型"></a>用list()和tuple()函数来转换类型</h5><p>函数list()和tuple()将返回传递给它们的值的列表和元组版本。</p><pre class=" language-python"><code class="language-python">tuple<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>list<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>list<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span></code></pre><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>你将42 赋给spam 变量，然后拷贝spam 中的值，将它赋给变量cheese。当稍后将spam中的值改变为100 时，这不会影响cheese 中的值。这是因为spam和cheese是不同的变量，保存了不同的值。</p><p><strong>但是，列表不是这样的</strong>，当你将列表赋给一个变量时，实际上是将列表的“引用”赋给了该变量。引用是一个值，指向某些数据。列表引用是指向一个列表的值。<br><strong>列表变量实际上没有包含列表</strong>，而是包含了对列表的“引用”（这些引用包含一些ID 数字，Python 在内部使用这些ID，但是你可以忽略）。</p><h5 id="传递引用"><a href="#传递引用" class="headerlink" title="传递引用"></a>传递引用</h5><p>要理解参数如何传递给函数，引用就特别重要。当函数被调用时，<strong>参数的值被复制给变元</strong>。<strong>对于列表（以及字典</strong>，我将在下一章中讨论），这意味着<strong>变元得到的是引用的拷贝</strong>。</p><ul><li><p>copy 模块的copy()和deepcopy()函数</p><blockquote><p>cheese = copy.copy(spam)<br>如果要复制的列表中包含了列表，那就使用copy.deepcopy()函数来代替。<br>Python 编程快速上手——让繁琐工作自动化deepcopy()函数将同时复制它们内部的列表。</p></blockquote></li></ul><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><strong>像列表一样</strong>，“字典”是许多值的集合。但不像列表的下标，<strong>字典的索引可以使用许多不同数据类型</strong>，不只是整数。<strong>字典的索引被称为“键”</strong>，键及其关联的值称为“键-值”对。</p><p>字典输入时带花括号{}</p><blockquote><p>spam = {12345: ‘Luggage Combination’, 42: ‘The Answer’}</p></blockquote><h5 id="字典与列表"><a href="#字典与列表" class="headerlink" title="字典与列表"></a>字典与列表</h5><p><strong>不像列表，字典中的表项是不排序的</strong>。名为spam 的列表中，第一个表项是spam[0]。但字典中没有“第一个”表项。虽然确定两个列表是否相同时，表项的顺序很重要，<strong>但在字典中，键-值对输入的顺序并不重要。</strong></p><p>两个字典 键值对相同，顺序不同，最后两个字典相同</p><ul><li><p>keys()、values()和items()方法,分别对应于字典的键、值和键-值对</p><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> v <span class="token keyword">in</span> spam<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token keyword">for</span> k <span class="token keyword">in</span> spam<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> spam<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#多重赋值</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> spam<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Key: '</span> <span class="token operator">+</span> k <span class="token operator">+</span> <span class="token string">' Value: '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><p>list(spam.keys())代码行接受keys()函数返回的dict_keys 值，并传递给list()。然后返回一个列表，即[‘color’, ‘age’]。</p><ul><li><p>检查字典中是否存在键或值   in,  not in</p></li><li><p>get()方法 字典有一个get()方法，它有两个参数：要取得其值的键，以及如果该键不存在时，返回的备用值。<strong>第二个参数是备用值</strong></p></li><li><p>setdefault()方法 你常常需要为字典中<strong>某个键设置一个默认值</strong>，当该键没有任何值时使用它。</p><blockquote><p>传递给该方法的第一个参数，是要检查的键。第二个参数，是如果该键不存在时要设置的值。如果该键确实存在，方法就会返回键的值</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数</title>
      <link href="2021/01/14/python-han-shu/"/>
      <url>2021/01/14/python-han-shu/</url>
      
        <content type="html"><![CDATA[<p>[python函数和参数](#### python函数和参数)</p><p>[函数作用域](#### 函数作用域)</p><a id="more"></a><h4 id="python函数和参数"><a href="#python函数和参数" class="headerlink" title="python函数和参数"></a>python函数和参数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func_name</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">:</span>    code space</code></pre><p>return 语句</p><h5 id="None值"><a href="#None值" class="headerlink" title="None值"></a>None值</h5><p>print()函数返回一个None值</p><p>对于所有没有return 语句的函数定义，Python 都会在末尾加上return None。</p><p>如果使用不带值的return 语句（也就是只有return 关键字本身），那么就返回None。</p><p>return None和  return 都返回None</p><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p><strong>在被调用函数内赋值</strong>的变元和变量，处于该函数的“<strong>局部作用域</strong>”。<strong>在所有函数之外赋值</strong>的变量，属于“<strong>全局作用域</strong>”。处于局部作用域的变量，被称为“局部变量”。处于全局作用域的变量，被称为“全局变量”。<strong>一个变量必是其中一种</strong>，不能既是局部的又是全局的。</p><p><strong>全局作用域</strong>，它是在程序开始时创建的。如果程序终止，全局作用域就被销毁，它的所有变量就被丢弃了</p><p>一个<strong>函数被调用时</strong>，就创建了一个局部作用域。在这个函数内赋值的所有变量，存在于该局部作用域内。<strong>该函数返回时</strong>，这个局部作用域就被销毁了，这些变量就丢失了。</p><p>全局变量可以在局部作用域中读取</p><h5 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h5><ul><li>如果需要在一个函数内修改全局变量，就使用global 语句。如果在函数的顶部有global eggs 这样的代码，它就告诉Python，“在这个函数中，eggs 指的是全局变量，所以不要用这个名字创建一个局部变量。”</li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">spam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> eggs    eggs <span class="token operator">=</span> <span class="token string">'spam'</span>eggs <span class="token operator">=</span> <span class="token string">'global'</span>spam<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>eggs<span class="token punctuation">)</span>输出结果： spam</code></pre><p>因为eggs 在spam()的顶部被声明为global，所以当eggs 被赋值为’spam’时，赋值发生在全局作用域的spam 上。没有创建局部spam 变量。</p><p>有4 条法则，来区分一个变量是处于局部作用域还是全局作用域：<br>1．如果变量在全局作用域中使用（即在所有函数之外），它就总是全局变量。<br>2．如果在一个函数中，有针对该变量的global 语句，它就是全局变量。<br>3．否则，如果该变量用于函数中的赋值语句，它就是局部变量。<br>4．但是，如果该变量没有用在赋值语句中，它就是全局变量。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    code space<span class="token keyword">except</span> Error<span class="token punctuation">:</span>    code space</code></pre>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> python </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字符串</title>
      <link href="2021/01/13/python-zi-fu-chuan/"/>
      <url>2021/01/13/python-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<p>[python字符串](#### python字符串)<br>[python操作符](#### python操作符)<br>[python控制流语句](#### python控制流语句)  </p><a id="more"></a><h4 id="python字符串"><a href="#python字符串" class="headerlink" title="python字符串"></a>python字符串</h4><p>Python中字符串和数字不能自动转换，需要 str()、int()、float()三个函数进行转换。</p><p>int()能对  <strong>整数</strong>字符串转化为整数，也能对浮点数进行取整</p><p>str()将整数或者浮点数转化为字符串</p><p>input()函数总是返回一个 <strong>字符串</strong>，如果读入数字，需要用 Int()转换</p><ul><li>虽然数字的字符串值被认为与整型值和浮点型值完全不同，但整型值可以与浮点值相等。</li></ul><p>42==42.0  True            42==’42’  False</p><p>Python 进行这种区分，因为字符串是文本，而整型值和浮点型都是数字。</p><p>类真 类假<br>对于 0、0.0、’’(空字符串) 被认为是False ,其他值被认为是True (Java不是)</p><h4 id="python操作符"><a href="#python操作符" class="headerlink" title="python操作符"></a>python操作符</h4><p>一元 == != &gt; &lt;  &gt;=  &lt;=  not<br>二元 and or   在类C语言中是  &amp;&amp; ||<br>True and True    True or False</p><h4 id="python控制流语句"><a href="#python控制流语句" class="headerlink" title="python控制流语句"></a>python控制流语句</h4><p><strong>if 语句包含以下部分：</strong></p><ul><li>if 关键字；</li><li>条件（即求值为True 或False 的表达式）；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为if 子句）。<pre><code>if condition: code space</code></pre></li><li>*else语句**</li><li>else 关键字；</li><li>冒号；</li><li>在下一行开始，缩进的代码块（称为else 子句）。<pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> condition<span class="token punctuation">:</span> code space<span class="token keyword">else</span><span class="token punctuation">:</span> code space</code></pre></li></ul><pre><code>**elif语句*** elif 关键字；* 条件（即求值为True 或False 的表达式）；* 冒号；* 在下一行开始，缩进的代码块（称为elif 子句）。```pythonif condition:     code space   elif condition:     code space</code></pre><p><strong>while loop</strong>  </p><ul><li><p>关键字；</p></li><li><p>条件（求值为True 或False 的表达式）；</p></li><li><p>冒号；</p></li><li><p>从新行开始，缩进的代码块（称为while 子句）。</p><pre><code>while condition:     code space</code></pre><p>break语句，提前跳出while循环子句<br>continue语句</p></li></ul><p><strong>for loop and range() function</strong></p><ul><li>for 关键字；</li><li>一个变量名；</li><li>in 关键字；</li><li>调用range()方法，最多传入3 个参数；</li><li>冒号；</li><li>从下一行开始，缩退的代码块（称为for 子句）。<pre><code>for var in range(5):    code space</code></pre>var 从0开始，循环5次，所以 0-4，没有5</li></ul><p><strong>range() begin、stop and step</strong><br>range(12,15) 第一个参数是for 循环变量开始的值，第二个参数是上限，但不包含它<br>range(0,10,2) 前两个参数分别是起始值和终止值，第三个参数是“步长”</p>]]></content>
      
      
      <categories>
          
          <category> python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neovim配置插件</title>
      <link href="2021/01/08/neovim-pei-zhi-cha-jian/"/>
      <url>2021/01/08/neovim-pei-zhi-cha-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="vim-plug的安装"><a href="#vim-plug的安装" class="headerlink" title="vim-plug的安装"></a>vim-plug的安装</h3><p>Neovim 和 Vim 一样，都是极为可拓展的纯文本编辑器，有着社区无数的插件支持，我们将使用专业、极简的插件管理器 —— <a href="https://github.com/junegunn/vim-plug">vim-plug</a> 来管理安装 Neovim 的插件。</p><p>默认安装情况下，在 Linux 与 macOS 中的 Neovim 配置文件位于 <code>~/.config/nvim/init.vim</code>，在 Windows 中位于 <code>%LOCALAPPDATA%\\nvim\\init.vim</code>，我们后续的配置操作都将会直接更改这一配置文件。</p><p><a href="https://github.com/junegunn/vim-plug">vim-plut GitHub页面，有安装教程</a></p><p><a href="https://www.cnblogs.com/lemos/p/7325079.html">init.vim的一些常用配置和常用插件</a></p><p><a href="https://www.cnblogs.com/wudongwei/p/8836047.html">vim-plug的下载安装和配置</a></p><h3 id="python环境配置"><a href="#python环境配置" class="headerlink" title="python环境配置"></a>python环境配置</h3><p>语法高亮、缩进线解决</p><p>还有语法检查、语法补全等</p><p><a href="https://juejin.cn/post/6844903844736925703">c/c++和Python开发环境vim配置</a></p><p><a href="https://xmfbit.github.io/2018/10/02/vim-you-complete-me/">VIM安装YouCompleteMe和Jedi进行自动补全</a></p><p><a href="https://zhuanlan.zhihu.com/p/32404185?group_id=929422999389376512">python配置vim</a></p><p>youcompleteme 能够实现c/c++的补全，其他的目前都不能，可能得需要重新克隆，重新编译才行</p><p>Kite 修改kite.vim的158行  pumvisible <c-n> <tab>就能实现用 tab去选择补全</tab></c-n></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neovim </tag>
            
            <tag> vim-plug </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex的安装与配置</title>
      <link href="2021/01/08/latex-de-an-zhuang-yu-pei-zhi/"/>
      <url>2021/01/08/latex-de-an-zhuang-yu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="TexLive的安装"><a href="#TexLive的安装" class="headerlink" title="TexLive的安装"></a>TexLive的安装</h3><h5 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h5><p><a href="https://www.tug.org/texlive/acquire-netinstall.html">TexLive官网</a></p><ul><li>可以通过install-tl-windows.exe下载安装，但是好像太慢，普遍不用</li><li>可以点击下方有个    <a href="https://www.tug.org/texlive/acquire.html">other installation methods</a>  链接进入，点击 <a href="https://www.tug.org/texlive/acquire-iso.html">Downloading one huge ISO file</a> ，有代理的话 点击 <a href="http://mirror.ctan.org/systems/texlive/Images/">download from a nearby CTAN mirror</a> ，或者到下方的 <a href="http://ctan.org/mirrors">mirror list</a> 找一个离自己近的镜像，比如下面有Asia分区里的中国分区，里面有清华、北大的一些镜像。比如清华的镜像中，首页有个CTAN，点击进入，往上寻找 systems下有个 Tex Live,点击进入再点击Images。</li></ul><p><a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华大学的Tex Live镜像</a></p><img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/image-20210107221903931.png" class="" title="image-20210107221903931"><p>下载图中红框里的文件即可。</p><a id="more"></a><p><code>texlive2020-20200406.iso</code> 是目前从官方磁力链接下载到的文件。里面有 <code>install-tl-windows.bat</code> 和 <code>install-tl-advanced.bat</code> 这两个脚本（或称<code>批处理文件</code>），双击其中任何一个都可以在 Windows 上自动安装，其中前者可以配置安装位置与安装后的默认选项，在这里我推荐任何人都用 <code>install-tl-windows.bat</code> 进行安装。</p><p>1.点击<code>texlive2020.iso</code>，如果是<code>win10</code>系统，双击打开即可，然后双击打开其中的<code>install-tl-windows.bat</code></p><p>2.可修改安装路径，一般默认<code>C</code>盘，如果你空间不够可考虑其它盘，其它设置可点击左下角 <code>Advanced</code>.</p><img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/image-20210107222327376.png" class="" title="image-20210107222327376"><p>3.等待半个多小时，安装完成。</p><img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/image-20210107222400190.png" class="" title="image-20210107222400190"><img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/image-20210107222417612.png" class="" title="image-20210107222417612"><h3 id="TexLive在VSCode中的配置"><a href="#TexLive在VSCode中的配置" class="headerlink" title="TexLive在VSCode中的配置"></a>TexLive在VSCode中的配置</h3><p>编辑LaTex的IDE可以使用tex studio或者winEdit,但是有VSCode这个很强的文本编辑器，我就没有使用前面两个。</p><p>在VSCode插件市场内中搜索并安装 LaTex Workshop。</p><p>配置VSCode的settings.json</p><p>第一步，打开你的 VSCode 默认配置文件：<code>Ctrl</code> + <code>Shift</code> + <code>P</code>，输入 <code>default settings.json</code>，如下图：</p><img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/v2-d8c189c37f4fc4e76b6da55c7d314f0e_720w.jpg" class="" title="img"><p>将下面代码复制进入 settings.json文件中</p><pre class=" language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// ======================== LaTeX 设置 BEGIN  ========================</span>    <span class="token comment" spellcheck="true">// bibtex 格式</span>    <span class="token string">"latex-workshop.bibtex-format.tab"</span><span class="token punctuation">:</span> <span class="token string">"tab"</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 自动编译，全部关闭，当且仅当你认为有需要的时候才会去做编译</span>    <span class="token string">"latex-workshop.latex.autoBuild.run"</span><span class="token punctuation">:</span> <span class="token string">"never"</span><span class="token punctuation">,</span>    <span class="token string">"latex-workshop.latex.autoBuild.cleanAndRetry.enabled"</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 设置 latex-workshop 的 PDF　预览程序，external　指的是外部程序</span>    <span class="token comment" spellcheck="true">//这里我使用的Pdf预览程序市acrobat，你可以下载SumatraPDF代替</span>    <span class="token string">"latex-workshop.view.pdf.viewer"</span><span class="token punctuation">:</span> <span class="token string">"external"</span><span class="token punctuation">,</span>    <span class="token string">"latex-workshop.view.pdf.ref.viewer"</span><span class="token punctuation">:</span> <span class="token string">"external"</span><span class="token punctuation">,</span>    <span class="token string">"latex-workshop.view.pdf.external.viewer.command"</span><span class="token punctuation">:</span> <span class="token string">"D:/AcrobatDC/Acrobat/Acrobat.exe"</span><span class="token punctuation">,</span>    <span class="token string">"latex-workshop.view.pdf.external.viewer.args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">"%PDF%"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 配置正向、反向搜索：.tex -> .pdf</span>    <span class="token string">"latex-workshop.view.pdf.external.synctex.command"</span><span class="token punctuation">:</span> <span class="token string">"D:/AcrobatDC/Acrobat/Acrobat.exe"</span><span class="token punctuation">,</span>    <span class="token string">"latex-workshop.view.pdf.external.synctex.args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">// 正向搜索</span>        <span class="token string">"-forward-search"</span><span class="token punctuation">,</span>        <span class="token string">"%TEX%"</span><span class="token punctuation">,</span>        <span class="token string">"%LINE%"</span><span class="token punctuation">,</span>        <span class="token string">"-reuse-instance"</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 反向搜索</span>        <span class="token string">"-inverse-search"</span><span class="token punctuation">,</span>        <span class="token string">"\"D:/VScode/Microsoft VS Code/Code.exe\" \"D:/VScode/Microsoft VS Code/resources/app/out/cli.js\" -gr %f:%l"</span><span class="token punctuation">,</span>        <span class="token string">"%PDF%"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 这是一些独立的编译选项，可以作为工具被编译方案调用</span>    <span class="token string">"latex-workshop.latex.tools"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Windows 原生安装 TeX Live 2020 的编译选项</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"command"</span><span class="token punctuation">:</span> <span class="token string">"xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"-synctex=1"</span><span class="token punctuation">,</span>                <span class="token string">"-interaction=nonstopmode"</span><span class="token punctuation">,</span>                <span class="token string">"-file-line-error"</span><span class="token punctuation">,</span>                <span class="token string">"-pdf"</span><span class="token punctuation">,</span>                <span class="token string">"%DOCFILE%"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"pdflatex"</span><span class="token punctuation">,</span>            <span class="token string">"command"</span><span class="token punctuation">:</span> <span class="token string">"pdflatex"</span><span class="token punctuation">,</span>            <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"-synctex=1"</span><span class="token punctuation">,</span>                <span class="token string">"-interaction=nonstopmode"</span><span class="token punctuation">,</span>                <span class="token string">"-file-line-error"</span><span class="token punctuation">,</span>                <span class="token string">"%DOCFILE%"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// Windows Biber 编译</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Windows Biber"</span><span class="token punctuation">,</span>            <span class="token string">"command"</span><span class="token punctuation">:</span> <span class="token string">"biber"</span><span class="token punctuation">,</span>            <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"%DOCFILE%"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>        <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"bibtex"</span><span class="token punctuation">,</span>        <span class="token string">"command"</span><span class="token punctuation">:</span> <span class="token string">"bibtex"</span><span class="token punctuation">,</span>        <span class="token string">"args"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token string">"%DOCFILE%"</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 这是一些编译方案，会出现在 GUI 菜单里</span>    <span class="token string">"latex-workshop.latex.recipes"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.1 Windows 编译简单的小文档，这个选项不太常用，因为绝大多数文章都需要有参考文献索引</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Windows XeLaTeX 简单编译"</span><span class="token punctuation">,</span>            <span class="token string">"tools"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"xelatex"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"pdflatex"</span><span class="token punctuation">,</span>            <span class="token string">"tools"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"pdflatex"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.2 Windows 编译带有索引的论文，需要进行四次编译；-> 符号只是一种标记而已，没有程序上的意义</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Windows xe->bib->xe->xe 复杂编译"</span><span class="token punctuation">,</span>            <span class="token string">"tools"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"xelatex"</span><span class="token punctuation">,</span>                <span class="token string">"bibtex"</span><span class="token punctuation">,</span>                <span class="token string">"xelatex"</span><span class="token punctuation">,</span>                <span class="token string">"xelatex"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>         <span class="token punctuation">{</span>            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"pdf->bib->pdf->pdf"</span><span class="token punctuation">,</span>            <span class="token string">"tools"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>                <span class="token string">"pdflatex"</span><span class="token punctuation">,</span>                <span class="token string">"bibtex"</span><span class="token punctuation">,</span>                <span class="token string">"pdflatex"</span><span class="token punctuation">,</span>                <span class="token string">"pdflatex"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>          <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 清空中间文件</span>    <span class="token string">"latex-workshop.latex.clean.fileTypes"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">"*.aux"</span><span class="token punctuation">,</span>        <span class="token string">"*.bbl"</span><span class="token punctuation">,</span>        <span class="token string">"*.blg"</span><span class="token punctuation">,</span>        <span class="token string">"*.idx"</span><span class="token punctuation">,</span>        <span class="token string">"*.ind"</span><span class="token punctuation">,</span>        <span class="token string">"*.lof"</span><span class="token punctuation">,</span>        <span class="token string">"*.lot"</span><span class="token punctuation">,</span>        <span class="token string">"*.out"</span><span class="token punctuation">,</span>        <span class="token string">"*.toc"</span><span class="token punctuation">,</span>        <span class="token string">"*.acn"</span><span class="token punctuation">,</span>        <span class="token string">"*.acr"</span><span class="token punctuation">,</span>        <span class="token string">"*.alg"</span><span class="token punctuation">,</span>        <span class="token string">"*.glg"</span><span class="token punctuation">,</span>        <span class="token string">"*.glo"</span><span class="token punctuation">,</span>        <span class="token string">"*.gls"</span><span class="token punctuation">,</span>        <span class="token string">"*.ist"</span><span class="token punctuation">,</span>        <span class="token string">"*.fls"</span><span class="token punctuation">,</span>        <span class="token string">"*.log"</span><span class="token punctuation">,</span>        <span class="token string">"*.fdb_latexmk"</span><span class="token punctuation">,</span>        <span class="token string">"*.bcf"</span><span class="token punctuation">,</span>        <span class="token string">"*.run.xml"</span><span class="token punctuation">,</span>        <span class="token string">"*.synctex.gz"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// ======================== LaTeX 设置 END ========================</span></code></pre><p>​          <img src="/2021/01/08/latex-de-an-zhuang-yu-pei-zhi/image-20210107223057127.png" class="" title="最后结果界面展示"></p><p><a href="https://sspai.com/post/60844">一个参考：少数派 使用 Git+LaTeX 完成你的毕业设计</a></p><h5 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h5><p>可在<code>.tex</code>文件首行指定编译方式。如<code>%! TEX program = pdflatex</code>表示用<code>latexpdf</code>编译文件。<code>%! TEX program = xelatex</code>表示用<code>xelatex</code>编译文件。</p><p>多个文件情况，可以用<code>%! TEX root</code>指定主文件，<code>%! TEX bib</code>指定<code>bib</code>的编译方式</p><h5 id="如果编译报错"><a href="#如果编译报错" class="headerlink" title="如果编译报错"></a>如果编译报错</h5><p>如果报错：<strong>Recipe terminated with fatal error: spawn xelatex ENOENT</strong> 等</p><p>可检查自己的环境变量，<strong>默认应该是只在用户变量里安装</strong>，<strong>自己添加到系统变量的<code>PATH</code>里</strong>，直到VScode里可以检测到(亲测可用，原来是只有cmd里能检测到！)</p><ul><li>如果添加到系统变量的PATH仍然不能使用，重启电脑即可。</li></ul><h3 id="TexLive在Neovim中的配置"><a href="#TexLive在Neovim中的配置" class="headerlink" title="TexLive在Neovim中的配置"></a>TexLive在Neovim中的配置</h3><p>专为 LaTeX 编写设计的 <a href="https://github.com/lervag/vimtex">vimtex</a> 插件是 Neovim 撰写 LaTeX 的绝佳搭档，我们将使用 vimtex 来辅助我们在 Neovim 中撰写 LaTeX 项目。默认安装情况下，在 Linux 与 macOS 中的 Neovim 配置文件位于 <code>~/.config/nvim/init.vim</code>，在 Windows 中位于 <code>%LOCALAPPDATA%\\nvim\\init.vim</code>，我们后续的配置操作都将会直接更改这一配置文件。</p><p>待续。。。。 </p><p>安装完成vimtux插件后，需要在init.vim中配置相关操作。</p><p><a href="https://sspai.com/post/64080">使用Neovim和vimtex高效撰写LaTex学术论文</a></p><p><a href="https://macplay.github.io/posts/shi-yong-latexmk-bian-yi-tex-wen-jian/">使用 Latexmk 编译 tex 文件</a></p><p><a href="https://blog.csdn.net/Null_0_lluN/article/details/108456462">vimtex的配置</a></p><h3 id="LaTeX编译流程"><a href="#LaTeX编译流程" class="headerlink" title="LaTeX编译流程"></a>LaTeX编译流程</h3><h3 id="撰写、预览-LaTeX-文档时，编辑器背后究竟在干什么？"><a href="#撰写、预览-LaTeX-文档时，编辑器背后究竟在干什么？" class="headerlink" title="撰写、预览 LaTeX 文档时，编辑器背后究竟在干什么？"></a>撰写、预览 LaTeX 文档时，编辑器背后究竟在干什么？</h3><p>很多集成度很高的编辑器（比如 TeXstudio）将编译 LaTeX 文档的整个过程隐藏在复杂的界面背后，实际上不易于我们理解 LaTeX 的完整编译闭环。因此，当我们在使用 Neovim 或者其他编辑器来撰写 LaTeX 文档时，我们实际上是做这样的一件事情：</p><ul><li>我们使用纯文本编辑器（Neovim）编辑 <code>.tex</code> 文件的文本内容，也就是 LaTeX 文档本身；</li><li>在后台运行的latexmk发现我们的.tex文件内容发生了变化，于是开始编译新增内容：<ul><li><code>latexmk</code> 会根据我们的 <code>.tex</code> 文件具体更改内容动态的调整编译命令和编译次数；</li><li>比如新增了参考文献的引用，则需要使用 <code>biber</code> 编译，或是增加了新的图表以及相应的引用，则需要两次至四次的调用 <code>pdflatex</code> 编译文档……</li></ul></li><li>编译后会生成相应的 <code>.pdf</code> 文件来给我们预览，我们使用合适的 PDF 阅读器打开即可；</li><li>最后，同步编辑器和 PDF 阅读器的显示位置的任务，通常会使用 SyncTeX 来完成。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
            <tag> Neovim </tag>
            
            <tag> vsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>powershell设置代理</title>
      <link href="2021/01/08/powershell-she-zhi-dai-li/"/>
      <url>2021/01/08/powershell-she-zhi-dai-li/</url>
      
        <content type="html"><![CDATA[<h3 id="配置PowerShell命令行"><a href="#配置PowerShell命令行" class="headerlink" title="配置PowerShell命令行"></a>配置PowerShell命令行</h3><p>PowerShell中有些情况需要使用代理，比如在PowerShell下使用git clone命令。</p><p>我们需要将这两个命令写入powershell启动脚本（类似linux的<code>.bashrc</code>），windows启动脚本在哪儿？</p><p>[PowerShell的启动脚本在哪儿？](### PowerShell启动脚本)</p><pre class=" language-powershell"><code class="language-powershell"><span class="token keyword">function</span> set_proxy_variable <span class="token punctuation">{</span>    <span class="token function">Set-Item</span> Env:http_proxy <span class="token string">"http://127.0.0.1:1080"</span>  <span class="token comment" spellcheck="true"># 代理地址</span>    <span class="token function">Set-Item</span> Env:https_proxy <span class="token string">"http://127.0.0.1:1080"</span> <span class="token comment" spellcheck="true"># 代理地址</span><span class="token punctuation">}</span><span class="token keyword">function</span> unset_proxy_variable <span class="token punctuation">{</span>    <span class="token function">Remove-Item</span> Env:http_proxy    <span class="token function">Remove-Item</span> Env:https_proxy<span class="token punctuation">}</span><span class="token function">New-Alias</span> <span class="token operator">-</span>Name spp <span class="token operator">-</span>Value set_proxy_variable<span class="token function">New-Alias</span> <span class="token operator">-</span>Name upp <span class="token operator">-</span>Value unset_proxy_variable</code></pre><h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><p>如果打开新的poewrshell窗口报<code>此系统上禁止运行脚本</code>错误，需要设置运行策略。</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">Set</span><span class="token operator">-</span>ExecutionPolicy <span class="token operator">-</span>ExecutionPolicy RemoteSigned <span class="token operator">-</span>Scope CurrentUser</code></pre><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><code>spp</code> 启用代理</li><li><code>upp</code> 取消代理</li></ul><h3 id="PowerShell启动脚本"><a href="#PowerShell启动脚本" class="headerlink" title="PowerShell启动脚本"></a>PowerShell启动脚本</h3><p>Linux中bash有一个启动的默认配置文件：<code>.bashrc</code>或者<code>.bash_profile</code>，自定义命令以及预配置可以写在那里，但是windows的配置文件在哪里呢？</p><p>windows 10 1903版本上的配置文件的实际路径</p><table><thead><tr><th align="left">Description</th><th align="left">Path</th></tr></thead><tbody><tr><td align="left">All Users, All Hosts</td><td align="left"><code>$PsHome\profile.ps1</code></td></tr><tr><td align="left">All Users, Current Host</td><td align="left"><code>$PsHome\Microsoft.PowerShell_profile.ps1</code></td></tr><tr><td align="left">Current User, All Hosts</td><td align="left"><code>$Home\Documents\WindowsPowerShell\profile.ps1</code></td></tr><tr><td align="left">Current user, Current Host</td><td align="left"><code>$Home\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</code></td></tr></tbody></table><p>然后就是按照路径创建配置文件，终于可以写点自定义命令了。</p><p>以下几种方法应该也可以，但我没有试过，以后有机会再说。</p><p><a href="https://blog.niekun.net/archives/97.html">powershell设置代理一种方法</a></p><p><a href="https://blog.jsmvp.com/post/2020/03/06/how-to-set-the-HTTP-proxy-for-cmdpowershell">第二种方法</a></p><p><a href="https://async.sh/2018/07/30/quick-setup-http-proxy-using-powershell-profile/">第三种方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PowerShell </tag>
            
            <tag> 代理配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Wrangling</title>
      <link href="2021/01/01/data-wrangling/"/>
      <url>2021/01/01/data-wrangling/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机教育中缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器部署JavaWeb项目流程</title>
      <link href="2020/12/31/a-li-yun-fu-wu-qi-bu-shu-javaweb-xiang-mu-liu-cheng/"/>
      <url>2020/12/31/a-li-yun-fu-wu-qi-bu-shu-javaweb-xiang-mu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>阿里云服务器部署JavaWeb项目完整流程</p><ol><li>确保tomcat、jdk、mysql、redis等常用软件安装配置完成，环境变量设置完成。</li><li>配置（修改）tomcat server.xml文件，开放服务器相应端口达到远程访问的目的。</li><li>idea打包JavaWeb项目（war包）。</li><li>上传到tomcat对应文件夹的位置。</li><li>访问ip+路径即可。</li></ol><a id="more"></a><h3 id="安装所需软件"><a href="#安装所需软件" class="headerlink" title="安装所需软件"></a>安装所需软件</h3><p>一个JavaWeb项目通常需要 tomcat jdk mysql redis等常用软件，可以按需下在项目对应版本进行使用，比如tomcat9 jdk8 mysql8等安装自己想要的版本。</p><p>卸载自带版本软件 可以 通过 <code>yum remove softwareName</code> </p><p>也可以<code>rpm -qa | grep tomcat</code> 命令查找软件信息后删除，具体操作百度、谷歌最好。</p><ul><li>可以通过 ·<code>yum install softwareName</code>  进行安装，但是这个不一定能够安装自己想要的版本。</li><li>也可以通过下载源码，编译安装或者下载压缩包（绿色安装，解压完开箱即用）。</li></ul><h5 id="tomcat安装"><a href="#tomcat安装" class="headerlink" title="tomcat安装"></a>tomcat安装</h5><p><a href="https://tomcat.apache.org/download-90.cgi">tomcat下载地址</a></p><ol><li>下载tomcat可以手动下载然后用 <code>rz</code>命令传送到Linux服务器上，也可以通过以下命令直接下载。</li></ol><ul><li><code>wget http://apache.mirrors.pair.com/tomcat/tomcat-9/v9.0.37/bin/apache-tomcat-9.0.37.tar.gz</code></li></ul><ol start="2"><li>解压缩，命令： <code>tar -xzvf  softwareName.tar.gz</code>,解压后可以重命名，要不然名字太长了。</li><li>上面解压缩后一般放到 /usr/local/   文件夹下，这个文件夹是放自己下载的文件的，大家这样，不太了解为啥。不过规范一下，不要乱放。</li><li>解压缩后，进入解压后（重命名后）的tomcat文件夹下的 bin目录中， 可以运行启动或者停止命令。启动后，可以通过浏览器访问   <code>YourIp:8080</code>   这个url如果看到 tomcat主页，就是tomcat运行成功。</li></ol><p><code>./startup.sh 启动  </code>    <code>./shutdown.sh   关闭</code>    </p><p><strong>添加环境变量</strong> （方便操作）：编辑    /etc/profile文件  在文件的最后添加以下内容：</p><pre class=" language-markdown"><code class="language-markdown">export CATALINA<span class="token italic"><span class="token punctuation">_</span>HOME=usr/local/tomcat/tomcat9  (tomcat9是我重命名的文件，我先创建了一个tomcat文件夹才将压缩文件解压缩放入，重复了)export PATH=$PATH:$CATALINA<span class="token punctuation">_</span></span>HOME/bin</code></pre><p>编辑 /etc/profile文件夹用 <code>vim /etc/profile</code> 打开，编辑完成后 <code>:wq</code>退出，不了解vim的可以学习下，不难的。</p><p><strong>开放端口</strong>：服务器开放端口后，外部才能访问到相关内容。 tomcat默认端口8080，所以需要开放8080端口。下面这个链接过程很清晰 ，不再重复了：</p><p><a href="https://www.cnblogs.com/Ferda/p/13305986.html">tomcat的安装，有如何开放端口的流程，步骤清晰，可参考</a></p><p><strong>除了开放8080端口，也可以直接将tomcat的默认8080端口修改为  80</strong>，这样当tomcat运行后，你通过url访问的时候就可以不带 :8080  了，可以通过ip 直接访问。操作方法如下：</p><ol><li><p>进入tomcat 文件夹下的 conf文件夹 ，打开 server.xml文件夹（ <code>vim server.xml</code>）</p></li><li><img src="/2020/12/31/a-li-yun-fu-wu-qi-bu-shu-javaweb-xiang-mu-liu-cheng/image-20201231155654462.png" class="" title="image-20201231155654462"></li></ol><p>​    将Connector标签中的 port 修改为80， <code>:wq</code>保存退出。</p><h6 id="Web项目部署"><a href="#Web项目部署" class="headerlink" title="Web项目部署"></a>Web项目部署</h6><p><strong>如果要部署JavaWeb项目就要修改 server.xml，部署项目一般都是将war包放在 /usr/local/tomcat/webapps 目录下，然后如果要进行访问的话还需要在server.xml中添加一行，完成后就可以正常访问。（ip:port/path或者ip/path(如果你修改了默认端口)）</strong></p><img src="/2020/12/31/a-li-yun-fu-wu-qi-bu-shu-javaweb-xiang-mu-liu-cheng/image-20201231160551231.png" class="" title="image-20201231160551231"><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span>docBase要改成你的项目目录。</span><span class="token title important"><span class="token punctuation">#</span>path为虚拟路径,访问时的路径，注意:不是根目录的，如果是其他路径比如"/test"一定要加"/"" debug建议设置为0</span><span class="token title important"><span class="token punctuation">#</span>reloadable设置为true</span></code></pre><p>添加 Context标签  docBase是 war包的名字（不带.war），path是url中的添加的访问路径，可配置有或没有。</p><p>添加完成，运行tomcat就可以进行访问。</p><h5 id="安装jdk8"><a href="#安装jdk8" class="headerlink" title="安装jdk8"></a>安装jdk8</h5><p>和安装tomcat差不多， 下载，解压，配置环境，即完成。以下链接写的十分详细，流程清晰，可参考：<a href="https://www.cnblogs.com/jpfss/p/9677827.html">使用centOS7卸载自带JDK安装自己的JDK8</a></p><h5 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h5><p>忘了，以后遇到再补上。。。。</p><h5 id="安装Redis-并设置远程访问。"><a href="#安装Redis-并设置远程访问。" class="headerlink" title="安装Redis,并设置远程访问。"></a>安装Redis,并设置远程访问。</h5><p><strong>Redis是编译安装</strong>，编译前需要下载一些依赖，像gcc什么的（挺多的），主要流程忘记了，以后遇到再填坑。。。<br>该链接将<strong>如何配置Redis环境变量</strong>和<strong>开放 Redis远程连接</strong>写的还算清楚，可参考（其实主要流程和设置tomcat远程连接类似，环境变量设置都相同）：<br><a href="https://www.cnblogs.com/mowen120/p/11933810.html">redis的安装与连接</a></p><p>Redis设置远程连接其实主要就是<strong>开放端口</strong>和<strong>修改配置</strong>，开放端口上面有，修改配置是：</p><p>先打开**/usr/local/redis** 下的文件   <strong>redis.conf,</strong> 然后修改：</p><ol><li>查找 bind 127.0.0.1  ，找到后注释掉   前面加个#号即可</li><li>搜索 protected-mode 将yes改成no</li><li>搜索 daemonize  修改成yes ,  这个是  是否在后台运行，不影响是否远程连接</li></ol><p><strong>redis可以配置密码</strong> ，搜索# requirepass foobared  ,去掉注释，将foobared修改为自己的密码即可。</p><h3 id="IDEA打包"><a href="#IDEA打包" class="headerlink" title="IDEA打包"></a>IDEA打包</h3><p><a href="https://blog.csdn.net/zeal9s/article/details/90711508">IDEA打包流程</a></p><h3 id="部署到Tomcat"><a href="#部署到Tomcat" class="headerlink" title="部署到Tomcat"></a>部署到Tomcat</h3><p>安装tomcat流程最后讲了如何部署和访问，<a href="Web%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2">Web项目部署</a></p><p><a href="https://juejin.cn/post/6844904052153647111">java项目部署Linux服务器几种启动方式总结经验</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署JavaWeb项目 </tag>
            
            <tag> Linux软件安装 </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Editors(vim)</title>
      <link href="2020/12/20/editors-vim/"/>
      <url>2020/12/20/editors-vim/</url>
      
        <content type="html"><![CDATA[<p>通常学习使用一个新的编辑器包含以下步骤：</p><ul><li>阅读教程（比如这节课以及我们为您提供的资源）</li><li>坚持使用它来完成你所有的编辑工作（即使一开始这会让你的工作效率降低）</li><li>随时查阅：如果某个操作看起来像是有更方便的实现方法，一般情况下真的会有。</li></ul><h3 id="Vim的哲学"><a href="#Vim的哲学" class="headerlink" title="Vim的哲学"></a>Vim的哲学</h3><p>在编程的时候，你会把大量时间花在阅读/编辑而不是在写代码上。所以， Vim 是一个 <strong><em>多模态</em></strong> 编辑 器： 它对于插入文字和操纵文字有不同的模式。 Vim 既是可编程的 （可以使用 Vimscript 或者像 Python 一样的其他程序语言）， Vim 的接口本身也是一个程序语言： 键入操作 （以及其助记名） 是命令， 这些命令也是可组合的。 Vim 避免了使用鼠标，因为那样太慢了； Vim 甚至避免用 上下左右键因为那样需要太多的手指移动。</p><p>这样的设计哲学的结果是一个能跟上你思维速度的编辑器。</p><a id="more"></a><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>Vim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式：</p><ul><li><em>正常模式</em>：在文件中四处移动光标进行修改</li><li><em>插入模式</em>：插入文本</li><li><em>替换模式</em>：替换文本</li><li><em>可视化（一般，行，块）模式</em>：<strong>选中文本块</strong></li><li><em>命令模式</em>：用于执行命令</li></ul><p>在不同的操作模式下， 键盘敲击的含义也不同。比如，<code>x</code> 在插入模式会插入字母<code>x</code>，但是在正常模式 会删除当前光标所在下的字母，在可视模式下则会删除选中文块。</p><p>你可以按下 <code>&lt;ESC&gt;</code> （逃脱键） 从任何其他模式返回正常模式。 在正常模式，键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式， <code>v</code> 进入可视（一般）模式， <code>V</code> 进入可视（行）模式， <code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式， <code>:</code> 进入命令模式。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h5><p>在正常模式， 键入 <code>i</code> 进入插入模式。 现在 Vim 跟很多其他的编辑器一样， 直到你键入<code>&lt;ESC&gt;</code> 返回正常模式。 你只需要掌握这一点和上面介绍的所有基知识就可以使用 Vim 来编辑文件了 （虽然如果你一直停留在插入模式内不一定高效）。</p><h5 id="缓存，-标签页，-窗口"><a href="#缓存，-标签页，-窗口" class="headerlink" title="缓存， 标签页， 窗口"></a>缓存， 标签页， 窗口</h5><p>Vim 会<strong>维护一系列打开的文件</strong>，称为 “缓存”。 <strong>一个 Vim 会话包含一系列标签页</strong>，<strong>每个标签页包含 一系列窗口 （分隔面板</strong>）。<strong>每个窗口显示一个缓存</strong>。 跟网页浏览器等其他你熟悉的程序不一样的是， <strong>缓存和窗口不是一一对应的关系</strong>； 窗口只是视角。 <strong>一个缓存可以在 <em>多个</em> 窗口打开</strong>，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用， <strong>比如在查看同一个文件的不同部分的时候</strong>。</p><p>Vim 默认打开一个标签页，这个标签也包含一个窗口。</p><p><code>:sp    ^wi（下面窗口）     ^wk(上面窗口)</code></p><h5 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h5><p>在正常模式下键入 <code>:</code> 进入命令行模式。 在键入 <code>:</code> 后，你的光标会立即跳到屏幕下方的命令行。 这个模式有很多功能， 包括打开， 保存， 关闭文件， 以及 <a href="https://twitter.com/iamdevloper/status/435555976687923200">退出 Vim</a>。</p><ul><li><p><code>:q</code> 退出 （关闭窗口）</p></li><li><p><code>:w</code> 保存 （写）</p></li><li><p><code>:wq</code> 保存然后退出</p></li><li><p><code>:e {文件名}</code> 打开要编辑的文件</p></li><li><p><code>:ls</code> 显示打开的缓存</p></li><li><pre class=" language-plaintext"><code class="language-plaintext">:help {标题}</code></pre></li></ul><p>  打开帮助文档</p><ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li><li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li></ul><h3 id="Vim-的接口其实是一种编程语言"><a href="#Vim-的接口其实是一种编程语言" class="headerlink" title="Vim 的接口其实是一种编程语言"></a>Vim 的接口其实是一种编程语言</h3><p>Vim <strong>最重要的设计思想</strong>是 <strong>Vim 的界面本身是一个程序语言</strong>。 <strong>键入操作 （以及他们的助记名） 本身是命令</strong>， 这些命令<strong>可以组合使用</strong>。 这使得移动和编辑更加高效，特别是一旦形成肌肉记忆。</p><h5 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h5><p>多数时候你会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被成为 “名词”， 因为它们指向文字块。</p><ul><li><p>基本移动: <code>hjkl</code> （左， 下， 上， 右）</p></li><li><p>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</p></li><li><p>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</p></li><li><p>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</p></li><li><p>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</p></li><li><p>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</p></li><li><p>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</p></li><li><p>杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</p></li><li><p>查找：</p><pre class=" language-plaintext"><code class="language-plaintext">f{字符},t{字符},F{字符},T{字符}</code></pre><ul><li>查找/到 向前/向后 <strong>在本行的</strong>{字符}</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul></li><li><p>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</p></li></ul><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><p>可视化模式:</p><ul><li>可视化</li><li>可视化行</li><li>可视化块</li></ul><p>可以用移动命令来选中。</p><h5 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h5><p>所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。</p><ul><li><pre class=" language-plaintext"><code class="language-plaintext">i </code></pre><p>进入插入模式</p><ul><li>但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li><p><code>O</code> / <code>o</code> 在之上/之下插入行</p></li><li><pre class=" language-plaintext"><code class="language-plaintext">d{移动命令}</code></pre><p>删除 {移动命令}</p><ul><li>例如， <code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li></ul></li><li><pre class=" language-plaintext"><code class="language-plaintext">c{移动命令}</code></pre><p>改变 {移动命令}</p><ul><li>例如， <code>cw</code> 改变词</li><li>比如 <code>d{移动命令}</code> 再 <code>i</code></li></ul></li><li><p><code>x</code> 删除字符 （等同于 <code>dl</code>）</p></li><li><p><code>s</code> 替换字符 （等同于 <code>xi</code>）</p></li><li><p>可视化模式 + 操作</p><ul><li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><p><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</p></li><li><p><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</p></li><li><p><code>p</code> 粘贴</p></li><li><p>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</p></li></ul><h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><p>你可以用一个计数来结合“名词” 和 “动词”， 这会执行指定操作若干次。</p><ul><li><code>3w</code> 向前移动三个词</li><li><code>5j</code> 向下移动5行</li><li><code>7dw</code> 删除7个词</li></ul><h5 id="修饰语"><a href="#修饰语" class="headerlink" title="修饰语"></a>修饰语</h5><p>你可以用<strong>修饰语改变 “名词” 的意义</strong>。修饰语有 <code>i</code>， <strong>表示 “内部” 或者 “在内“</strong>， 和 <code>a</code>， <strong>表示 ”周围“</strong>。</p><ul><li><code>ci(</code> 改变当前括号内的内容</li><li><code>ci[</code> 改变当前方括号内的内容</li><li><code>da'</code> 删除一个单引号字符窗， 包括周围的单引号</li></ul><h3 id="自定义-Vim"><a href="#自定义-Vim" class="headerlink" title="自定义 Vim"></a>自定义 Vim</h3><p>Vim 由一个<strong>位于 <code>~/.vimrc</code> 的文本配置文件</strong> （包含 Vim 脚本命令）。 你可能会启用很多基本 设置。</p><p>我们提供一个文档详细的基本设置， 你可以用它当作你的初始设置。 我们推荐使用这个设置因为 它修复了一些 Vim 默认设置奇怪行为。 <strong>在 <a href="https://missing-semester-cn.github.io/2020/files/vimrc">这儿</a> 下载我们的设置， 然后将它保存成 <code>~/.vimrc</code>.</strong></p><p>Vim 能够被重度自定义， 花时间探索自定义选项是值得的。 你可以参考其他人的在 GitHub 上共享的设置文件， 比如， 你的授课人的 Vim 设置 (<a href="https://github.com/anishathalye/dotfiles/blob/master/vimrc">Anish</a>, <a href="https://github.com/jonhoo/configs/blob/master/editor/.config/nvim/init.vim">Jon</a> (uses <a href="https://neovim.io/">neovim</a>), <a href="https://github.com/JJGO/dotfiles/blob/master/vim/.vimrc">Jose</a>)。 有很多好的博客文章也聊到了这个话题。 尽量不要复制粘贴别人的整个设置文件， 而是阅读和理解它， 然后采用对你有用的部分。</p><h3 id="扩展-Vim"><a href="#扩展-Vim" class="headerlink" title="扩展 Vim"></a>扩展 Vim</h3><p>Vim 有很多扩展插件。 跟很多互联网上已经过时的建议相反， 你 <em>不</em> 需要在 Vim 使用一个插件 管理器（从 Vim 8.0 开始）。 你可以使用内置的插件管理系统。 只需要创建一个 <code>~/.vim/pack/vendor/start/</code> 的文件夹， 然后把插件放到这里 （比如通过 <code>git clone</code>）。</p><p>以下是一些我们最爱的插件：</p><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim">ctrlp.vim</a>: 模糊文件查找</li><li><a href="https://github.com/mileszs/ack.vim">ack.vim</a>: 代码搜索</li><li><a href="https://github.com/scrooloose/nerdtree">nerdtree</a>: 文件浏览器</li><li><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>: 魔术操作</li></ul><p>我们尽量避免在这里提供一份冗长的插件列表。 你可以查看讲师们的开源的配置文件 (<a href="https://github.com/anishathalye/dotfiles">Anish</a>, <a href="https://github.com/jonhoo/configs">Jon</a>, <a href="https://github.com/JJGO/dotfiles">Jose</a>) 来看看我们使用的其他插件。 浏览 <a href="https://vimawesome.com/">Vim Awesome</a> 来了解一些很棒的插件。 这个话题也有很多博客文章： 搜索 “best Vim plugins”。</p><h3 id="其他程序的-Vim-模式"><a href="#其他程序的-Vim-模式" class="headerlink" title="其他程序的 Vim 模式"></a>其他程序的 Vim 模式</h3><p>很多工具提供了 Vim 模式。 这些 Vim 模式的质量参差不齐； 取决于具体工具， 有的提供了 很多酷炫的 Vim 功能， 但是大多数对基本功能支持的很好。</p><h5 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h5><p>如果你是一个 Bash 用户， 用 <code>set -o vi</code>。 如果你用 Zsh： <code>bindkey -v</code>。 Fish 用 <code>fish_vi_key_bindings</code>。 另外， 不管利用什么 shell， 你可以 <code>export EDITOR=vim</code>。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如， <code>git</code> 会使用这个编辑器来编辑 commit 信息。</p><h5 id="Readline"><a href="#Readline" class="headerlink" title="Readline"></a>Readline</h5><p>很多程序使用 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html">GNU Readline</a> 库来作为 它们的命令控制行界面。 Readline 也支持基本的 Vim 模式， 可以通过在 <code>~/.inputrc</code> 添加如下行开启：</p><pre><code>set editing-mode vi</code></pre><p>比如， 在这个设置下， Python REPL 会支持 Vim 快捷键。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>甚至有 Vim 的网页浏览快捷键 <a href="http://vim.wikia.com/wiki/Vim_key_bindings_for_web_browsers">browsers</a>, 受欢迎的有 用于 Google Chrome 的 <a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en">Vimium</a> 和用于 Firefox 的 <a href="https://github.com/tridactyl/tridactyl">Tridactyl</a>。 你甚至可以在 <a href="https://github.com/lambdalisue/jupyter-vim-binding">Jupyter notebooks</a> 中用 Vim 快捷键。</p><h3 id="Vim-进阶"><a href="#Vim-进阶" class="headerlink" title="Vim 进阶"></a>Vim 进阶</h3><p>这里我们提供了一些展示这个编辑器能力的例子。我们无法把所有的这样的事情都教给你， 但是你 可以在使用中学习。 一个好的对策是: 当你在使用你的编辑器的时候感觉 “一定有更好的方法来做这个”， 那么很可能真的有： 上网搜寻一下。</p><h5 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h5><p><code>:s</code> （替换） 命令 （<a href="http://vim.wikia.com/wiki/Search_and_replace">文档</a>）。</p><ul><li><pre class=" language-plaintext"><code class="language-plaintext">%s/foo/bar/g</code></pre><ul><li>在整个文件中将 foo 全局替换成 bar</li></ul></li><li><pre class=" language-plaintext"><code class="language-plaintext">%s/\[.*\](\(.*\))/\1/g</code></pre><ul><li>将有命名的 Markdown 链接替换成简单 URLs</li></ul></li></ul><h5 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h5><ul><li>用 <code>:sp</code> / <code>:vsp</code> 来分割窗口</li><li>同一个缓存可以在多个窗口中显示。</li></ul><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li><p><code>q{字符}</code> 来开始在寄存器 <code>{字符}</code> 中录制宏</p></li><li><p><code>q</code> 停止录制</p></li><li><p><code>@{字符}</code> 重放宏</p></li><li><p>宏的执行遇错误会停止</p></li><li><p><code>{计数}@{字符}</code> 执行一个宏 {计数} 次</p></li><li><p>宏可以递归</p><ul><li>首先用 <code>q{字符}q</code> 清除宏</li><li>录制该宏， 用 <code>@{字符}</code> 来递归调用该宏 （在录制完成之前不会有任何操作）</li></ul></li><li><p>例子： 将 xml 转成 json (</p><p>file</p><p>)</p><ul><li><p>一个有 “name” / “email” 键对象的数组</p></li><li><p>用一个 Python 程序？</p></li><li><p>用 sed / 正则表达式</p><ul><li><code>g/people/d</code></li><li><code>%s/&lt;person&gt;/{/g</code></li><li><code>%s/&lt;name&gt;\(.*\)&lt;\/name&gt;/"name": "\1",/g</code></li><li>…</li></ul></li><li><p>Vim 命令 / 宏</p><ul><li><p><code>Gdd</code>, <code>ggdd</code> 删除第一行和最后一行</p></li><li><p>格式化最后一个元素的宏 （寄存器</p></li></ul></li></ul></li></ul><pre><code>  ```plaintext  e  ```  ）  - 跳转到有 `&lt;name&gt;` 的行  - `qe^r"f&gt;s": "&lt;ESC&gt;f&lt;C"&lt;ESC&gt;q`- 格式化一个人的宏  - 跳转到有 `&lt;person&gt;` 的行  - `qpS{&lt;ESC&gt;j@eA,&lt;ESC&gt;j@ejS},&lt;ESC&gt;q`- 格式化一个人然后转到另外一个人的宏  - 跳转到有 `&lt;person&gt;` 的行  - `qq@pjq`- 执行宏到文件尾  - `999@q`- 手动移除最后的 `,` 然后加上 `[` 和 `]` 分隔符</code></pre><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><ul><li><code>vimtutor</code> 是一个 Vim 安装时自带的教程</li><li><a href="https://vim-adventures.com/">Vim Adventures</a> 是一个学习使用 Vim 的游戏</li><li><a href="http://vim.wikia.com/wiki/Vim_Tips_Wiki">Vim Tips Wiki</a></li><li><a href="https://vimways.org/2019/">Vim Advent Calendar</a> 有很多 Vim 小技巧</li><li><a href="http://www.vimgolf.com/">Vim Golf</a> 是用 Vim 的用户界面作为程序语言的 <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a></li><li><a href="https://vi.stackexchange.com/">Vi/Vim Stack Exchange</a></li><li><a href="http://vimcasts.org/">Vim Screencasts</a></li><li><a href="https://pragprog.com/book/dnvim2/practical-vim-second-edition">Practical Vim</a> （书）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机教育中缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell工具和脚本</title>
      <link href="2020/12/19/shell-gong-ju-he-jiao-ben/"/>
      <url>2020/12/19/shell-gong-ju-he-jiao-ben/</url>
      
        <content type="html"><![CDATA[<h3 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h3><p>上一课，我们已经学习来如何在shell中<strong>执行命令</strong>，并使用<strong>管道将命令组合使用</strong>。<br>但是，很多情况下我们需要执行一系列的操作并使用<strong>条件</strong>或<strong>循环</strong>这样的控制流。</p><p>shell脚本是一种更加复杂的工具</p><p>大多数shell都有自己的一套脚本语言，包括变量、控制流和自己的语法。</p><p>在bash中<strong>为变量赋值</strong>的语法是<code>foo=bar</code>，<strong>访问变量</strong>中存储的数值，其语法为 <code>$foo</code>。</p><ul><li>注意的是，<code>foo = bar</code> （使用括号隔开）是不能正确工作的，因为解释器会调用程序<code>foo</code> 并将 <code>=</code> 和 <code>bar</code>作为<strong>参数</strong>。</li><li> 总的来说，在shell脚本中使用<strong>空格会起到分割参数</strong>的作用，有时候可能会造成混淆，请务必多加检查。</li></ul><p>Bash中的字符串通过<code>'</code> 和 <code>"</code>分隔符来定义，但是它们的含义并不相同。以<code>'</code>定义的字符串为<strong>原义字符串</strong>，其中的变量不会被转义，而 <code>"</code>定义的字符串<strong>会将变量值进行替换</strong>。</p><pre class=" language-bash"><code class="language-bash">foo<span class="token operator">=</span>bar<span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$foo</span>"</span><span class="token comment" spellcheck="true"># 打印 bar</span><span class="token keyword">echo</span> <span class="token string">'<span class="token variable">$foo</span>'</span><span class="token comment" spellcheck="true"># 打印 $foo</span></code></pre><a id="more"></a><p><code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， , <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。</p><pre class=" language-bash"><code class="language-bash">mcd <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">mkdir</span> -p <span class="token string">"<span class="token variable">$1</span>"</span>    <span class="token function">cd</span> <span class="token string">"<span class="token variable">$1</span>"</span><span class="token punctuation">}</span></code></pre><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本到参数。 <code>$1</code> 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令到返回值</li><li><code>$$</code> - 当前脚本到进程识别码</li><li><code>!!</code> - 完整到上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码，便于脚本以更加友好到方式报告错误。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</p><p><strong>/dev/null</strong> ：代表空设备文件</p><blockquote><p><strong>&gt;</strong> ：代表重定向到哪里，例如：echo “123” &gt; /home/123.txt<br><strong>1</strong> ：表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”<br><strong>2</strong> ：表示stderr标准错误<br>**&amp;** ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote><blockquote><p><strong>1 &gt; /dev/null 2&gt;&amp;1</strong> 语句含义：<br>1 &gt; /dev/null ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。<br>2&gt;&amp;1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p></blockquote><p>退出码可以搭配<code>&amp;&amp;</code> (与操作符) 和 <code>||</code> (或操作符)使用，用来进行条件判断，决定是否执行其他程序。程序 <code>true</code> 的返回码永远是<code>0</code>，<code>false</code> 的返回码永远是<code>1</code>。</p><pre class=" language-bash"><code class="language-bash"><span class="token boolean">false</span> <span class="token operator">||</span> <span class="token keyword">echo</span> <span class="token string">"Oops, fail"</span><span class="token comment" spellcheck="true"># Oops, fail</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token keyword">echo</span> <span class="token string">"Will not be printed"</span><span class="token comment" spellcheck="true">#</span><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"Things went well"</span><span class="token comment" spellcheck="true"># Things went well</span><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> <span class="token string">"Will not be printed"</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#同一行的多个命令可以用` ; `分隔。</span><span class="token boolean">false</span> <span class="token punctuation">;</span> <span class="token keyword">echo</span> <span class="token string">"This will always run"</span><span class="token comment" spellcheck="true"># This will always run</span></code></pre><p>另一个常见的模式是<strong>以变量的形式获取一个命令的输出</strong>，这可以通过 <strong><em>命令替换</em></strong> (<em>command substitution</em>)实现。</p><p>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code> 这个命令时，然后它的输出结果会替换掉 <code>$( CMD )</code> 。</p><ul><li>例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。</li></ul><p>还有一个冷门的类似特性是 <strong><em>进程替换</em></strong>（<em>process substitution</em>）， <code>&lt;( CMD )</code> 会执行 <code>CMD</code> 并<strong>将结果输出到一个临时文件中</strong>，并将 <code>&lt;( CMD )</code> 替换成临时文件名。这在我们<strong>希望返回值通过文件而不是STDIN传递时很有用</strong>。</p><ul><li>例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo</code> 和 <code>bar</code> 中文件的区别。</li></ul><p>这段脚本会遍历我们提供的参数，使用<code>grep</code> 搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"Starting program at <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span> <span class="token comment" spellcheck="true"># date会被替换成日期和时间</span><span class="token keyword">echo</span> <span class="token string">"Running program <span class="token variable">$0</span> with <span class="token variable">$#</span> arguments with pid $$"</span><span class="token keyword">for</span> <span class="token function">file</span> <span class="token keyword">in</span> <span class="token variable">$@</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token function">grep</span> foobar <span class="token variable">$file</span> <span class="token operator">></span> /dev/null 2<span class="token operator">></span> /dev/null    <span class="token comment" spellcheck="true"># 如果模式没有找到，则grep退出状态为 1</span>    <span class="token comment" spellcheck="true"># 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -ne 0 <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token keyword">echo</span> <span class="token string">"File <span class="token variable">$file</span> does not have any foobar, adding one"</span>        <span class="token keyword">echo</span> <span class="token string">"# foobar"</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">$file</span>"</span>    <span class="token keyword">fi</span><span class="token keyword">done</span></code></pre><p>Bash实现了<strong>许多类似的比较操作</strong>，您可以查看 <a href="http://man7.org/linux/man-pages/man1/test.1.html"><code>test 手册</code></a>。<br>在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code> 而不是单方括号 <code>[ ]</code>，这样会降低犯错的几率</p><p><em>通配</em>（ <em>globbing</em>）</p><ul><li>通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 <code>?</code> 和 <code>*</code> 来匹配一个或任意个字符。例如，对于文件<code>foo</code>, <code>foo1</code>, <code>foo2</code>, <code>foo10</code> 和 <code>bar</code>, <code>rm foo?</code>这条命令会删除<code>foo1</code> 和 <code>foo2</code> ，而<code>rm foo*</code> 则会删除除了<code>bar</code>之外的所有文件。</li><li>花括号<code>{}</code> - 当你有一系列的指令，其中<strong>包含一段公共子串时</strong>，可以<strong>用花括号来自动展开这些命令。</strong>这在批量移动或转换文件时非常方便。（写完后，用 Tab键扩展完整字符串）</li></ul><pre class=" language-bash"><code class="language-bash">convert image.<span class="token punctuation">{</span>png,jpg<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 会展开为</span>convert image.png image.jpg<span class="token function">cp</span> /path/to/project/<span class="token punctuation">{</span>foo,bar,baz<span class="token punctuation">}</span>.sh /newpath<span class="token comment" spellcheck="true"># 会展开为</span><span class="token function">cp</span> /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath<span class="token comment" spellcheck="true"># 也可以结合通配使用</span><span class="token function">mv</span> *<span class="token punctuation">{</span>.py,.sh<span class="token punctuation">}</span> folder<span class="token comment" spellcheck="true"># 会移动所有 *.py 和 *.sh 文件</span><span class="token function">mkdir</span> foo bar<span class="token comment" spellcheck="true"># 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件</span><span class="token function">touch</span> <span class="token punctuation">{</span>foo,bar<span class="token punctuation">}</span>/<span class="token punctuation">{</span>a<span class="token punctuation">..</span>h<span class="token punctuation">}</span><span class="token function">touch</span> foo/x bar/y<span class="token comment" spellcheck="true"># 显示foo和bar文件的不同</span><span class="token function">diff</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>ls foo<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>ls bar<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出</span><span class="token comment" spellcheck="true"># &lt; x</span><span class="token comment" spellcheck="true"># ---</span><span class="token comment" spellcheck="true"># > y</span></code></pre><ul><li><a href="https://github.com/koalaman/shellcheck">shellcheck</a>这样的工具可以帮助你定位sh/bash脚本中的错误。</li></ul><p>shell知道去用python解释器而不是shell命令来运行这段脚本，是因为<strong>脚本的开头第一行</strong>的<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a>。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/local/bin/python</span><span class="token keyword">import</span> sys<span class="token keyword">for</span> arg <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span></code></pre><p>在shebang行中使用 <a href="http://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令是一种好的实践，它会<strong>利用环境变量中</strong>的程序来解析该脚本，这样就<strong>提高来您的脚本的可移植性</strong>。<code>env</code> 会利用我们第一节讲座中介绍过的<code>PATH</code> 环境变量来进行定位。</p><ul><li> 例如，使用了<code>env</code>的shebang看上去时这样的<code>#!/usr/bin/env python</code>。</li></ul><h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h4><p>man 命令</p><ul><li>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，<strong>同时还有其标记列表</strong>，包括之前我们介绍过的<code>-i</code>。 </li></ul><p>有时候手册内容<strong>太过详实</strong>，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很<strong>不错的替代品</strong>，它提供了一些案例，可以帮助您快速找到正确的选项。</p><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p>程序员们面对的最常见的重复任务就是<strong>查找文件或目录</strong>。<br>一个名为 <a href="http://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a>的工具，它是shell上用于查找文件的绝佳工具。<code>find</code>命令会<strong>递归地搜索符合条件</strong>的文件，例如：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找所有名称为src的文件夹</span><span class="token function">find</span> <span class="token keyword">.</span> -name src -type d<span class="token comment" spellcheck="true"># 查找所有文件夹路径中包含test的python文件</span><span class="token function">find</span> <span class="token keyword">.</span> -path <span class="token string">'**/test/**/*.py'</span> -type f<span class="token comment" spellcheck="true"># 查找前一天修改的所有文件</span><span class="token function">find</span> <span class="token keyword">.</span> -mtime -1<span class="token comment" spellcheck="true"># 查找所有大小在500k至10M的tar.gz文件</span><span class="token function">find</span> <span class="token keyword">.</span> -size +500k -size -10M -name <span class="token string">'*.tar.gz'</span></code></pre><p>例如， <a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的<strong>替代品</strong>。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p><blockquote><p>不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。:</p><p><code>locate</code> 使用一个由 <a href="http://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="http://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>每日更新。<br><code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">here</a>有一个更详细的对比。</p></blockquote><h4 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h4><p>很多时候您的目标其实是查看文件的内容。<br>一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p><blockquote><p>为了实现这一点，很多类UNIX的系统都提供了<a href="http://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a>命令，它是用于对输入文本进行匹配的通用工具。</p></blockquote><p>因此也出现了很多它的<strong>替代品</strong>，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查找所有使用了 requests 库的文件</span>rg -t py <span class="token string">'import requests'</span><span class="token comment" spellcheck="true"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span>rg -u --files-without-match <span class="token string">"^#!"</span><span class="token comment" spellcheck="true"># 查找所有的foo字符串，并打印其之后的5行</span>rg foo -A 5<span class="token comment" spellcheck="true"># 打印匹配的统计信息（匹配的行和文件的数量）</span>rg --stats PATTERN</code></pre><h4 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h4><p>您可能想要找到之前输入过的某条命令。<br><strong>首先</strong>，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。<br><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令。<br>如果我们要<strong>搜索历史记录</strong>，则可以<strong>利用管道</strong>将输出结果传递给 <code>grep</code> 进行模式搜索。 </p><ul><li><p><code>history | grep find</code> 会打印包含find子串的命令。</p></li><li></li></ul><p>对于大多数的shell来说，您可以使用 <code>Ctrl+R</code> 对<strong>命令历史记录</strong>进行<strong>回溯搜索</strong>。敲 <code>Ctrl+R</code> 后您可以<strong>输入子串来进行匹配</strong>，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a>中，使用方向键上或下也可以完成这项工作。</p><ul><li><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</li><li><a href="https://www.geek-share.com/detail/2808482983.html">fzf和tldr的安装方法</a></li></ul><h4 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h4><p><a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell和脚本</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机教育中缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程概览和shell</title>
      <link href="2020/12/18/ke-cheng-gai-lan-he-shell/"/>
      <url>2020/12/18/ke-cheng-gai-lan-he-shell/</url>
      
        <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>计算机最擅长帮助我们完成重复性的工作，这一点也适用于我们<strong>使用计算机的方式</strong>，而不仅仅是利用计算机程序去帮我们求解问题。<br>本课程促使我们想去探索更多的工具。</p><h3 id="课程结构"><a href="#课程结构" class="headerlink" title="课程结构"></a>课程结构</h3><p>本课程包含 11 个时长在一小时左右的讲座，每一个讲座都会关注一个 <a href="https://missing-semester-cn.github.io/missing-semester/2020/">特定的主题</a>。（基本各自独立）</p><h3 id="主题1：The-Shell"><a href="#主题1：The-Shell" class="headerlink" title="主题1：The Shell"></a>主题1：The Shell</h3><h4 id="shell是什么？"><a href="#shell是什么？" class="headerlink" title="shell是什么？"></a>shell是什么？</h4><p>现在计算机的交互接口有炫酷的图像用户界面（GUI），语音输入甚至AR/VR都无处不在。这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。</p><p>为了充分利用计算机的能力，最根本的方式使用文字接口：shell</p><p>核心功能：它允许你执行程序，输入并获取某种半结构化的输出。</p><h4 id="使用shell"><a href="#使用shell" class="headerlink" title="使用shell"></a>使用shell</h4><p>打开终端，会看到提示符，看起来是：<br><code>[root@computer_name ~]#                        </code>  </p><p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>root</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <code>$</code> 符号表示您现在的身份不是 root 用户，#表示现在是root用户。</p><pre class=" language-bash"><code class="language-bash">missing:~$ <span class="token keyword">echo</span> hellohello</code></pre><p><code>echo</code> 程序将该参数打印出来。 <strong>shell 基于空格分割命令并进行解析</strong>，然后执行<strong>第一个单词代表的程序</strong>，并将<strong>后续的单词作为程序可以访问的参数</strong>。如果您希望<strong>传递的参数中包含空格</strong>（例如一个名为 My Photos 的文件夹），<strong>您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理</strong>（<code>My\ Photos</code>）。</p><p>shell 是<strong>如何知道去哪里寻找</strong> <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，<strong>shell 是一个编程环境</strong>，所以它具备<strong>变量</strong>、<strong>条件</strong>、<strong>循环</strong>和<strong>函数</strong></p><p>当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。</p><p>如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去查找 <em>环境变量</em> <code>$PATH</code>，它会列出当 shell 接到某条指令时，<strong>进行程序搜索的路径</strong></p><pre class=" language-bash"><code class="language-bash">missing:~$ <span class="token keyword">echo</span> <span class="token variable">$PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binmissing:~$ <span class="token function">which</span> <span class="token keyword">echo</span>/bin/echomissing:~$ /bin/echo <span class="token variable">$PATH</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></pre><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的<strong>一系列目录</strong>，<strong>基于名字搜索该程序</strong>。</p><p>确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。</p><h4 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h4><p>当前工作目录可以使用 <code>pwd</code> 命令来获取。</p><p>此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录。</p><p><strong>大多数的命令接受标记和选项</strong>（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。一个-是只有一个字母的，两个-是  连着单词的</p><pre class=" language-bash"><code class="language-bash">missing:~$ <span class="token function">ls</span> -l /homedrwxr-xr-x 1 missing  <span class="token function">users</span>  4096 Jun 15  2019 missing</code></pre><p>这个参数可以打印出更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录（- 表示是一个文件 还有表示链接的）。然后接下来的九个字符，每三个字符构成一组。 （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。</p><p>其中 <code>-</code> 表示该用户不具备相应的权限。<br>为了<strong>进入某个文件夹</strong>，用户需要具备该文件夹以及其父文件夹的“搜索”权限（<strong>以“可执行”：<code>x</code>）</strong>权限表示。<br>为了<strong>列出它的包含的内容</strong>，用户必须对该文件夹<strong>具备读权限（<code>r</code>）</strong>。</p><h4 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h4><p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。<br>当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个<strong>程序的输入输出流都是您的终端</strong>。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以<strong>重定向这些流</strong>！</p><p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p><pre class=" language-bash"><code class="language-bash">missing:~$ <span class="token keyword">echo</span> hello <span class="token operator">></span> hello.txtmissing:~$ <span class="token function">cat</span> hello.txthellomissing:~$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txthellomissing:~$ <span class="token function">cat</span> <span class="token operator">&lt;</span> hello.txt <span class="token operator">></span> hello2.txtmissing:~$ <span class="token function">cat</span> hello2.txthello</code></pre><p>还可以使用 <code>&gt;&gt;</code> 来向一个<strong>文件追加内容。</strong></p><p>使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。<br> <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p><pre class=" language-bash"><code class="language-bash">missing:~$ <span class="token function">ls</span> -l / <span class="token operator">|</span> <span class="token function">tail</span> -n1drwxr-xr-x 1 root  root  4096 Jun 20  2019 varmissing:~$ curl --head --silent google.com <span class="token operator">|</span> <span class="token function">grep</span> --ignore-case content-length <span class="token operator">|</span> <span class="token function">cut</span> --delimiter<span class="token operator">=</span><span class="token string">' '</span> -f2219</code></pre><p>有一件事情是您必须作为<strong>根用户才能做</strong>的，那就是向 <code>sysfs</code> 文件写入内容。<strong>系统被挂载在 <code>/sys</code> 下</strong>，<code>sysfs</code> 文件则<strong>暴露了一些内核（kernel）参数</strong>。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。</p><p>关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <strong><code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写</strong>。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> <strong>前</strong>尝试<strong>打开 brightness 文件并写入</strong>，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p><p><a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与shell</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机教育中缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础(1)</title>
      <link href="2020/12/08/java-ji-chu-1/"/>
      <url>2020/12/08/java-ji-chu-1/</url>
      
        <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>类继承或者接口实现</li><li>子类重写父类的方法override</li><li>父类的引用指向子类的对象（动态多态，运行期才能知道真正调用的是哪个类的方法）</li></ul><p>函数重载是静态多态，编译期就决定是调用哪个方法</p><p>争论：我会和面试官说：我认为，多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。</p><p><strong>重载（Overloading）</strong>和<strong>重写（Overriding）</strong></p><ol><li><strong>重载</strong>就是函数或者方法有<strong>同样的名称</strong>，但是<strong>参数列表不相同的情形</strong>，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li><li><strong>重写</strong>指的是在<strong>Java的子类与父类中有两个名称、参数列表都相同的方法</strong>的情况。</li></ol><p><strong>重写</strong>遵循所谓“<strong>运行期绑定</strong>”，即在运行的时候，根据引用变量所指向的<strong>实际对象的类型</strong>来调用方法</p><p><strong>重写条件</strong>：</p><ul><li><strong>参数列表</strong>、<strong>返回类型</strong>必须完全<strong>相同</strong></li><li>访问级别的限制性一定不能比被重写方法的强，但可以弱</li><li>重写方法一定<strong>不能抛出新的检查异常</strong>或比被重写的方法声明的检查异常更广泛的检查异常</li><li>不能重写被标示为final的方法；</li></ul><p><strong>构造器</strong>没有<strong>返回类型，不会被继承</strong>，且<strong>可以有范围修饰符。</strong>构造器的函数名称必须和它所属的类的名称相同。</p><h3 id="类变量、成员变量和局部变量"><a href="#类变量、成员变量和局部变量" class="headerlink" title="类变量、成员变量和局部变量"></a>类变量、成员变量和局部变量</h3><p>Java中共<strong>有三种变量，</strong>分别是类变量、成员变量和局部变量。他们分别存放在<strong>JVM的方法区、堆内存和栈内存中</strong>。</p><p>private: 表明该成员变量或者方法是私有的,只有当前类对其具有访问权限,<strong>子类也没有访问权限</strong><br>protected:表明成员变量或者方法对类自身,<strong>与同在一个包中的其他类可见</strong>,其他包下的类不可访问,<strong>除非是他的子类</strong><br>default:表明该成员变量或者方法只有自己和其位于同一个包的内可见,其他包内的类不能访问,<strong>即便是它的子类</strong></p><h3 id="值传递、引用传递"><a href="#值传递、引用传递" class="headerlink" title="值传递、引用传递"></a>值传递、引用传递</h3><p>值传递（pass by value）是指在调用函数时将<strong>实际参数</strong><code>复制</code>一份传递到函数中，这样在函数中如果对<code>参数</code>进行<strong>修改，将不会影响到实际参数</strong>。</p><p>引用传递（pass by reference）是指在调用函数时将<strong>实际参数的地址</strong><code>直接</code>传递到函数中，那么在函数中对<code>参数</code>所进行的<strong>修改，将影响到实际参数。</strong></p><h4 id="Java中只有值传递"><a href="#Java中只有值传递" class="headerlink" title="Java中只有值传递"></a>Java中只有值传递</h4><p>对象共享传递  <strong>Java会将对象的地址的拷贝传递给被调函数的形式参数</strong></p><h3 id="finally与return的关系"><a href="#finally与return的关系" class="headerlink" title="finally与return的关系"></a>finally与return的关系</h3><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的<strong>表达式运算</strong>之后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来）；</p><p>对于含有return语句的情况下，</p><ul><li><strong>情况一</strong>：如果finally中有return语句，则会将try中的return语句“覆盖”掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。</li><li><strong>情况二</strong>：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。</li><li><strong>情况三</strong>：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：<ul><li>1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。</li><li>2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。</li></ul></li></ul><p><strong>try-catch都有return语句时，没有异常时，返回值是try中的return返回的。</strong></p><p><strong>try块中抛出异常，try、catch和finally中都有return语句，返回值是finally中的return。</strong></p><h3 id="static的各种作用"><a href="#static的各种作用" class="headerlink" title="static的各种作用"></a>static的各种作用</h3><h3 id="构造函数的各种知识"><a href="#构造函数的各种知识" class="headerlink" title="构造函数的各种知识"></a>构造函数的各种知识</h3><h3 id="Java反射的各种知识"><a href="#Java反射的各种知识" class="headerlink" title="Java反射的各种知识"></a>Java反射的各种知识</h3><h3 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h3><h5 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h5><p>用final修饰的类不能被继承，即不能拥有自己的子类，否则编译会出错</p><h5 id="final-修饰方法"><a href="#final-修饰方法" class="headerlink" title="final 修饰方法"></a>final 修饰方法</h5><p>final修饰的方法<strong>不能被重写（可以被重载）</strong>。</p><ul><li>因为<strong>重写的前提是子类可以从父类中继承</strong>此方法，如果父类中final修饰的方法同时<strong>访问控制权限为private</strong>，将会导致子类中<strong>不能直接继承</strong>到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是<strong>在子类中重新定义了新的方法</strong>。</li></ul><h5 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h5><p>定义了final变量并在首次为其显示初始化后，final修饰的变量值不可被改变。</p><p>final修饰的变量，无论是<strong>类属性</strong>、<strong>对象属性</strong>、<strong>形参</strong>还是<strong>局部变量</strong>，这些变量都是需要进行显示初始化</p><p>对于final修饰的形参，由于是<strong>实参传递</strong>过来的</p><p><strong>final修饰的类属性和变量属性必须要进行显示初始化赋值。</strong></p><p>final变量赋值时刻：</p><ol><li>可以在变量定义时赋值</li><li>可以在代码块中进行赋值（静态代码块和构造代码块）</li><li>在构造方法中赋值</li><li>总之就时在对象创建之前完成赋值的过程</li></ol><p>final成员变量可以在构造函数里赋值</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><strong>switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后再使用switch的</strong></p><p>整形包括 int char short byte   JDK7之后也支持String，支持String是通过 hashCode()方法得到int值然后进行比较，<strong>最后增加 eaquals方法进行比较确认</strong></p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>JVM中，为了减少<strong>相同的字符串的重复创建</strong>，达到节省内存的目的，会单独开辟一块内存，<strong>用于保存字符串常量</strong>，叫做  <strong>字符串常量池</strong>：</p><p>当代码中出现<strong>双引号形式（字面量）创建字符串对象时</strong>，JVM 会<strong>先</strong>对这个字符串进行<strong>检查</strong>，<strong>如果</strong>字符串常量池中<strong>存在相同内容的字符串对象</strong>的引用，则将这个引用返回；<strong>否则</strong>，<strong>创建新的字符串对象</strong>，然后将这个引用放入字符串常量池，并返回该引用。</p><h3 id="Class常量池"><a href="#Class常量池" class="headerlink" title="Class常量池"></a>Class常量池</h3><p>Class常量池可以理解为是<strong>Class文件中的资源仓库</strong>。</p><p>Class文件中除了包含<strong>类的版本、字段、方法、接口等描述信息外</strong>，还有一项信息就是<strong>常量池</strong>(constant pool table)，用于<strong>存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。</strong></p><blockquote><p>在计算机科学中，<strong>字面量（literal）</strong>是用于表达源代码中一个<strong>固定值的表示法</strong>（notation）。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。</p></blockquote><blockquote><p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * <strong>类和接口的全限定名</strong> * <strong>字段的名称和描述符</strong> * <strong>方法的名称和描述符</strong></p></blockquote><ul><li>Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。</li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（ Runtime Constant Pool）是<strong>每一个类或接口的常量池（ Constant_Pool）的运行时表示形式。</strong></p><p>包括了若干种不同的常量：从编译期可知的<strong>数值字面量</strong>到必须运行期解析后才能获得的<strong>方法或字段引用。</strong></p><p>运行时常量池扮演了<strong>类似传统语言中符号表（ SymbolTable）的角色</strong>，不过它存储数据范围比通常意义上的符号表要更为广泛。</p><p><strong>每一个运行时常量池</strong>都分配在 Java 虚拟机的<strong>方法区</strong>之中，在<strong>类和接口被加载到虚拟机后</strong>，对应的运行时常量池就<strong>被创建出来</strong>。</p><p>运行时常量池中的内容包含：<strong>Class常量池中的常量、字符串常量池中的内容</strong></p><p><strong>包括了前面的两个常量池</strong></p><p><strong>字符串常量的长度不能超过65535。</strong></p><p>字符串有长度限制，<strong>在编译期</strong>，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。</p><p><strong>在运行期</strong>，长度不能超过Int的范围，否则会抛异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring注释/xml配置开发区别</title>
      <link href="2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/"/>
      <url>2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>XML开发方式</strong>（XML配置繁琐）</p><p><strong>Spring注解方式（有助于学习SpringBoot）</strong></p><hr><p>主要内容：</p><ul><li>IOC与DI</li><li>Spring的3种编程风格与2种注入方式</li><li>1️⃣XML配置开发：<bean>描述依赖关系</bean></li><li>自动装配：让<bean>职责单一化</bean></li><li>2️⃣XML+注解：XML+<a href="context:component-scan">context:component-scan</a>+@Component()</li><li>@Autowired的小秘密</li><li>2️⃣JavaConfig+注解：@Configuration+@ComponentScan+@Component</li><li>3️⃣JavaConfig方式：@Configuration+@Bean</li><li>大乱斗：@ImportResource、@Component、@Bean</li><li><a href="https://zhuanlan.zhihu.com/p/72668451">主要参考内容</a></li><li><a href="https://www.cnblogs.com/shz365/p/5088289.html">配合参考内容</a></li></ul><hr><a id="more"></a><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>不妨将IOC理解成一种思想，而DI是实现该思想的一种具体方式。Spring被称为IOC容器</p><img src="/2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/image-20201207220242109.png" class="" title="Spring IOC"><h3 id="Spring依赖注入的做法"><a href="#Spring依赖注入的做法" class="headerlink" title="Spring依赖注入的做法"></a>Spring依赖注入的做法</h3><p>通过配置信息（XML）来描述类与类之间的关系，然后通过IOC容器（Spring Context）去解析配置信息。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置信息：在XML中定义Bean --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.annotation.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--ref是参照的意思，在代码中表示person类中有该成员变量，依赖关系的表现--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.annotation.Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre><p>总结：</p><ul><li>配置信息用来描述类与类之间的关系（XML/注解/Configuration配置类都可以）</li><li>对象之间的依赖关系必须在类中定义好（依赖的成员作为成员变量，和配置中匹配）</li><li>Spring通过配置信息，用构造方法或者setter方法完成依赖注入</li></ul><h5 id="3种变成风格和两种注入方式"><a href="#3种变成风格和两种注入方式" class="headerlink" title="3种变成风格和两种注入方式"></a>3种变成风格和两种注入方式</h5><p>将Bean交给Spring管理的3种方式：</p><ul><li>XML配置</li><li>注解</li><li>@Configuration配置类</li></ul><p>注入方式：</p><ul><li>构造方法注入</li><li>setter方法注入</li></ul><img src="/2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/image-20201207221157075.png" class="" title="重点在下面"><h5 id="setter方法注入"><a href="#setter方法注入" class="headerlink" title="setter方法注入"></a>setter方法注入</h5><p>pom.xml</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.3.12.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p>配置信息（setter方法注入）</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 在xml中描述类与类的配置信息 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- property标签表示，让Spring通过setter方法注入--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>&lt;/bean</code></pre><p>Person类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Person依赖Car</span>    <span class="token keyword">private</span> Car car<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无参构造</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 有参构造</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过构造方法注入..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// setter方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCar</span><span class="token punctuation">(</span>Car car<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>car <span class="token operator">=</span> car<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过setter方法注入..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"car="</span> <span class="token operator">+</span> car <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong><em>在XML中配置依赖信息中，使用了  Property标签，所以spring会使用 setter方法注入</em></strong></p><h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 在xml中描述类与类的配置信息 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- constructor-arg标签表示，让Spring通过构造方法注入--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p><strong><em>在XML中配置依赖信息中，使用了  construtor-arg 标签，所以spring会使用 构造方法注入</em></strong></p><h3 id="自动装配：单一化-lt-bean-gt-的职责"><a href="#自动装配：单一化-lt-bean-gt-的职责" class="headerlink" title="自动装配：单一化 <bean>的职责"></a>自动装配：单一化 &lt;bean&gt;的职责</h3><p>&lt;bean&gt;这个标签有两个作用:</p><ul><li>定义bean，告诉Spring哪个Bean需要交给它管理（放入容器）</li><li>维护bean与bean之间的依赖关系</li></ul><p><strong>但是代码中已经描述了类与类之间的依赖关系，所以&lt;property&gt;和&lt;constructor-arg&gt;冗余了</strong></p><ul><li>既然类结构本身包含了依赖信息，&lt;bean&gt;再用&lt;property&gt;等去描述就显得多余了</li><li>如果类结构变动，我们还需要额外维护&lt;bean&gt;的依赖信息，很麻烦。比如Person新增了一个shoes字段，那么&lt;bean&gt;又要写一个&lt;property&gt;表示shoes</li></ul><h5 id="单一化职责"><a href="#单一化职责" class="headerlink" title="单一化职责"></a>单一化职责</h5><p>让&lt;bean&gt;标签职责单一化，让它只负责定义bean，把bean与bean的依赖关系转交给类自身维护</p><p>这就是自动装配</p><h5 id="两种自动装配"><a href="#两种自动装配" class="headerlink" title="两种自动装配"></a>两种自动装配</h5><p><strong>XML根标签&lt;beans&gt;末尾加default-autowire配置</strong></p><p>全体配置： 注意第六行</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span>        <span class="token attr-name">default-autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--重要--></span>     <span class="token comment" spellcheck="true">&lt;!-- 在xml中只定义bean，无需配置依赖关系 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Person<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p>局部自动装配（单个配置）每一个&lt;bean&gt;单独设置autowire</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 在xml中只定义bean，无需配置依赖关系 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>person<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Person<span class="token punctuation">"</span></span> <span class="token attr-name">autowire</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>byName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.xml.Car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>&lt;/bean</code></pre><h3 id="XML-注解：XML-context-component-scan-Component"><a href="#XML-注解：XML-context-component-scan-Component" class="headerlink" title="XML+注解：XML+context:component-scan+@Component"></a>XML+注解：XML+<a href="context:component-scan">context:component-scan</a>+@Component</h3><p>前面去除了&lt;bean&gt;的描述依赖的职责，<strong>这次再去除&lt;bean&gt;的定义bean的职责</strong></p><p><strong><em>这样就不需要在XML中写任何&lt;bean&gt;标签了。</em></strong> （普通spring整合好像都是这种方式进行开发）</p><p>原来是把<bean>写在XML中，再把XML喂给Spring：</bean></p><pre class=" language-java"><code class="language-java">ApplicationContext applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring-context.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="/2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/image-20201207225606101.png" class="" title="image-20201207225606101"><p>spring读取配置读到了两个内容：</p><ul><li>类名</li><li>装配模式（其实这个也不是必须的，默认no，不自动装配）</li></ul><p>现在简化这两个内容： 类名，写的类中就可获得名字，装配模式（其实不是必须的）</p><p><strong><em>用带注解的类代替&lt;bean&gt;标签</em></strong></p><p>现在：都用@Component、@Service等注解标记，</p><img src="/2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/image-20201207225621256.png" class="" title="image-20201207225621256"><img src="/2020/12/08/spring-zhu-shi-xml-pei-zhi-kai-fa-qu-bie/image-20201207231250492.png" class="" title="image-20201207231250492"><p>然后XML就只需要配置<strong>有@Component注解的类就是bean，和以前&lt;bean&gt;一样一样的。</strong></p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.bravo.annotation<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><p>标签的作用有两个：</p><ul><li>扫描：原先我们把写有bean定义的XML文件喂给Spring，现在则让Spring自己去指定路径下扫描bean定义</li><li>解析：让Spring具备解析注解的功能(@Component)</li></ul><p><strong>接下来还要配置自动装配的模式</strong>：</p><ul><li>@Autowired（Spring提供的） </li><li>@Resource（JSR-250定义）</li><li>@Inject（JSR-330定义）</li></ul><p>总结： 就是通过@Component注解<strong>去除 xml中的&lt;bean&gt;**，直接使用自己写的类；通过@Autowired</strong>告诉Spring 装配哪个依赖**</p><p><strong>@Autowired默认采用byType模式自动装配，如果找到多个同类型的，会根据名字匹配。都不匹配，则会报错。</strong></p><p>@Qualifier注解能指定名字，可以和@Autowired配合</p><p>这里@Autowired配置在属性上，还可以配置在setter 方法和构造函数方法上。都是自动注入。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 用@Autowired告知Spring：请把Car装配进来</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Car car<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person{"</span> <span class="token operator">+</span>                <span class="token string">"car="</span> <span class="token operator">+</span> car <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JavaConfig-注解：-Configuration-ComponentScan-Component"><a href="#JavaConfig-注解：-Configuration-ComponentScan-Component" class="headerlink" title="JavaConfig+注解：@Configuration+@ComponentScan+@Component"></a>JavaConfig+注解：@Configuration+@ComponentScan+@Component</h3><p><strong>注解@Configuration</strong>，目的是让我们可以把一个<strong>普通的Java类等同于一个XML文件</strong>，而这个Java类就是JavaConfig，我们习惯称之为配置类。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span> <span class="token comment" spellcheck="true">//表示这个Java类充当XML配置文件</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.bravo.javaconfig"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//相当于XML中的&lt;context:component-scan>标签</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="JavaConfig方式：-Configuration-Bean"><a href="#JavaConfig方式：-Configuration-Bean" class="headerlink" title="JavaConfig方式：@Configuration+@Bean"></a>JavaConfig方式：@Configuration+@Bean</h3><p>上面的做法<strong>并不是所谓的Java-based Container Configuration</strong>（@Configuration配置类）风格。我们虽然用到了@Configuration，但只是为了让Java配置类替代XML，最终消灭XML。</p><p>真正的Java-based Container Configuration编程风格是这样的：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//new一个Benz对象，通过@Bean注解告知Spring把这个bean加到容器</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Car <span class="token function">benz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Benz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//new一个Bmw对象，通过@Bean注解告知Spring把这个bean加到容器</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Car <span class="token function">bmw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bmw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//new一个Person对象，通过@Bean注解告知Spring把这个bean加到容器</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Person <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setCar</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Benz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Person、Benz、Bmw等类（去除@Component，那是注解开发方式）</p><p><strong>Java-based Container Configuration编程风格指的是：</strong></p><ul><li>用@Configuration把一个普通Java类变成配置类，充当XML</li><li>在配置类中写多个方法，加上@Bean把返回值对象加到Spring容器中</li><li>把配置类AppConfig喂给AnnotationConfigApplicationContext，让它像解析XML一样解析配置类</li><li>无需加@Component注解，因为我们可以手动new之后通过@Bean加入容器</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><p>纯XML配置开发：没有注解，全部<bean>标签，但也可以配置自动装配</bean></p></li><li><p>注解开发不能单独存在，需要<strong>开启扫描</strong>。自动装配一般用@Autowired</p></li><li><ul><li>XML+注解：XML+<strong><a href="context:component-scan">context:component-scan</a></strong>+@Component</li><li>JavaConfig+注解：@Configuration+<strong>@ComponentScan</strong>+@Component</li></ul></li><li><p>JavaConfig方式：@Configuration+@Bean</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> spring学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring基础 </tag>
            
            <tag> 注释、xml配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot学习二</title>
      <link href="2020/12/05/springboot-xue-xi-er/"/>
      <url>2020/12/05/springboot-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring注解-Resource和-Autowired区别对比"><a href="#Spring注解-Resource和-Autowired区别对比" class="headerlink" title="Spring注解@Resource和@Autowired区别对比"></a>Spring注解@Resource和@Autowired区别对比</h3><p>@Resource和@Autowired都是做bean的注入时使用，其实**@Resource并不是Spring的注解**，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p><strong>共同点</strong>：<br>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p><strong>不同点：</strong><br>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;<strong>只按照byType注入。</strong></p><p><strong>@Autowired注解是按照类型（byType）</strong>装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用</p><p><strong>@Resource默认按照ByName自动注入</strong>，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有<strong>两个重要的属性：name和type</strong>，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。</p><a id="more"></a><h3 id="spring注入Bean的几种方式"><a href="#spring注入Bean的几种方式" class="headerlink" title="spring注入Bean的几种方式"></a>spring注入Bean的几种方式</h3><ol><li>配置xml文件<code>    &lt;bean id="bean" class="beandemo.Bean" /&gt;</code><br>一个一个配太麻烦，可以通过一种注解实现注入的方法。只需要在你需要注入的类前面加上相应的注解，Spring就会帮助我们扫描到他们去实现注入。xml扫描包的方式<pre><code>`&lt;context:component-scan base-package="com.company.beandemo"/&gt;`</code></pre></li></ol><p>基于@Autowired的自动装配，默认是根据类型注入，可以用于构造器、字段、方法注入，使用方式如下：</p><p><strong>java代码：</strong></p><ol><li>@Autowired(required=<strong>true</strong>) </li><li>构造器、字段、方法 </li></ol><h5 id="通过构造方法注入Bean"><a href="#通过构造方法注入Bean" class="headerlink" title="通过构造方法注入Bean"></a>通过构造方法注入Bean</h5><p><strong>构造器注入：</strong>通过将@Autowired注解放在构造器上来完成构造器注入，默认构造器参数通过类型自动装配</p><ol><li><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>javass<span class="token punctuation">.</span>spring<span class="token punctuation">.</span>chapter12<span class="token punctuation">;</span>  <span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBean11</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span> String message<span class="token punctuation">;</span>   <span class="token annotation punctuation">@Autowired</span> <span class="token comment" spellcheck="true">//构造器注入  </span> <span class="token keyword">private</span> <span class="token function">TestBean11</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//省略message的getter和setter  </span><span class="token punctuation">}</span>  </code></pre></li><li><p>在Spring配置文件（chapter12/dependecyInjectWithAnnotation.xml）添加如下Bean配置：<br><code>&lt;bean id="testBean11" class="cn.javass.spring.chapter12.TestBean11"/&gt;  </code></p></li></ol><h5 id="通过set方法注入Bean"><a href="#通过set方法注入Bean" class="headerlink" title="通过set方法注入Bean"></a>通过set方法注入Bean</h5><p><strong>方法参数注入：</strong>通过将@Autowired注解放在方法上来完成方法参数注入。</p><pre class=" language-Java"><code class="language-Java">package&nbsp;cn.javass.spring.chapter12;&nbsp;&nbsp;import&nbsp;org.springframework.beans.factory.annotation.Autowired;&nbsp;&nbsp;public&nbsp;class&nbsp;TestBean13&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;message;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;//setter方法注入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setMessage(String&nbsp;message)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.message&nbsp;=&nbsp;message;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getMessage()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;message;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;}&nbsp;&nbsp;</code></pre><h5 id="通过属性-字段-注入Bean"><a href="#通过属性-字段-注入Bean" class="headerlink" title="通过属性(字段)注入Bean"></a>通过属性(字段)注入Bean</h5><p>1、准备测试Bean，在字段上添加@AutoWired注解：</p><pre class=" language-Java"><code class="language-Java">package&nbsp;cn.javass.spring.chapter12;&nbsp;&nbsp;import&nbsp;org.springframework.beans.factory.annotation.Autowired;&nbsp;&nbsp;public&nbsp;class&nbsp;TestBean12&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;//字段注入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;message;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//省略getter和setter&nbsp;&nbsp;}&nbsp;</code></pre><p>2、在Spring配置文件（chapter12/dependecyInjectWithAnnotation.xml）添加如下Bean配置：<br><code>&lt;bean id="testBean12" class="cn.javass.spring.chapter12.TestBean12"/&gt;  </code>同上</p><h5 id="静态工厂注入"><a href="#静态工厂注入" class="headerlink" title="静态工厂注入"></a>静态工厂注入</h5><h3 id="shiro整合redis"><a href="#shiro整合redis" class="headerlink" title="shiro整合redis"></a>shiro整合redis</h3>]]></content>
      
      
      <categories>
          
          <category> springboot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot学习一</title>
      <link href="2020/12/04/springboot-quan-ju-yi-chang-chu-li/"/>
      <url>2020/12/04/springboot-quan-ju-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot继承AbstractErrorController实现全局异常处理"><a href="#SpringBoot继承AbstractErrorController实现全局异常处理" class="headerlink" title="SpringBoot继承AbstractErrorController实现全局异常处理"></a>SpringBoot继承AbstractErrorController实现全局异常处理</h3><p>  项目中需要一个全局异常，防止未处理的异常信息直接暴露给前端（就是运行报错，错误栈直接在网页展示的情况），这影响用户的体验。</p><ul><li>SpringBoot中可以使用<strong>ControllerAdvice</strong>和<strong>ExceptionHandler</strong>这个两个注解来做全局异常（只能能处理Controller层之内的异常，对于渲染层及其他的异常是无能为力的。）<strong>ControllerAdvice</strong>定义统一的异常处理类，<strong>ExceptionHandler</strong>定义函数针对的异常类型，最后将Exception对象和请求URL映射到error.html中。<br><a href="http://blog.didispace.com/springbootexception/">学习相关内容连接</a></li><li>另一种是本文提到的方式</li></ul><a id="more"></a><p><strong>ControllerAdvice</strong>只能拦截 <strong>控制器</strong> 中的异常也就是500之类的异常，404这种不进入控制器处理的异常不起作用</p><p>原理：<br>        springboot会将所有的异常发送到路径为 server.error.path(application.properties中可配置，默认为”/error”)的控制器（Controller）方法中进行处理，页面请求和ajax请求会分别达到对应的处理方法上。<strong>有两个方法继承AbstractErrorController后要实现 一个是  errorHtml，另一个是 error方法。</strong> 构造函数要 显示 调用父类的构造函数并传入参数</p><pre class=" language-java"><code class="language-java">ExceptionEnum类是枚举类，枚举各种错误种类Result类返回错误信息的类，包含响应状态编码，响应信息等</code></pre><p>第一个方法<strong>errorHtml</strong>上标注了@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)，因此当请求类型是text/html，也即是<strong>通过浏览器访问时进入该方法</strong>，<strong>其他客户端访问时</strong>当然就进入第二个方法了，所以大家会发现在浏览器和Postman访问同一个错误路径时返回的数据是不同了，浏览器返回html，而postman返回json数据(自定义的返回数据类)。</p><p><a href="https://blog.csdn.net/hello_IT_/article/details/106174121?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai">本文方法的一些参考</a></p><p>本文处理流程原理：</p><ol><li><strong>ErrorPageCustomizer</strong>：系统出现错误后，来到 error 请求进行处理（类似 web.xml 注册的错误页面规则）</li><li><strong>BasicErrorController</strong>：处理默认/error请求</li><li><strong>DefaultErrorAttributes</strong>：通过getErrorAttributes获得异常的信息</li><li><strong>DefaultErrorViewResolver</strong>：返回错误页面（就是返回一个ModelAndView,可以自定义)</li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> springboot内容学习 </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习java的正则</title>
      <link href="2020/12/03/xue-xi-java-de-zheng-ze/"/>
      <url>2020/12/03/xue-xi-java-de-zheng-ze/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-regex包"><a href="#Java-regex包" class="headerlink" title="Java regex包"></a>Java regex包</h3><ul><li>Pattern类：pattern对象是一个正则表达式的编译表示。<br><code>Pattern pattern1 = Pattern.compile(pattern);</code></li><li>Matcher类：matcher对象是对输入字符串进行解释和匹配操作的引擎。需要调用Pattern对象的matcher方法来获得一个Matcher对象。<br><code>Matcher matcher = pattern1.matcher(line);</code></li></ul><a id="more"></a><h4 id="Matcher’s-method"><a href="#Matcher’s-method" class="headerlink" title="Matcher’s method"></a>Matcher’s method</h4><p>索引方法</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public int start()</strong> 返回以前匹配的初始索引。</td></tr><tr><td align="left">2</td><td align="left"><strong>public int start(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td align="left">3</td><td align="left"><strong>public int end()</strong> 返回最后匹配字符之后的偏移量。</td></tr><tr><td align="left">4</td><td align="left"><strong>public int end(int group)</strong> 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table><p>查找方法</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public boolean lookingAt()</strong>  尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td align="left">2</td><td align="left"><strong>public boolean find()</strong> 尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td align="left">3</td><td align="left"><strong>public boolean find(int start**</strong>）** 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td align="left">4</td><td align="left"><strong>public boolean matches()</strong> 尝试将整个区域与模式匹配。</td></tr></tbody></table><p>替换方法</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public Matcher appendReplacement(StringBuffer sb, String replacement)</strong> 实现非终端添加和替换步骤。</td></tr><tr><td align="left">2</td><td align="left"><strong>public StringBuffer appendTail(StringBuffer sb)</strong> 实现终端添加和替换步骤。</td></tr><tr><td align="left">3</td><td align="left"><strong>public String replaceAll(String replacement)</strong>  替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td align="left">4</td><td align="left"><strong>public String replaceFirst(String replacement)</strong>  替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td align="left">5</td><td align="left"><strong>public static String quoteReplacement(String s)</strong> 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</td></tr></tbody></table><p>appendReplacement和appendTail方法是在一起用的（一般情况下）</p><p>appendReplacement的作用是 用 替换字符串去替换 所有正则表达式匹配的字符串，然后将从字符串开头到 它最后一个正则匹配到的字符串的最后一个字符后 这一段字符串放入 StringBuffer中。</p><p>appendTail的作用是和上一个得到的字符串 和  上面匹配剩余的字符串 拼接成完成的字符串。</p><p>两个联合实现了字符串里 正则匹配到的字符串的被替换（新的替换旧的）</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分辨实体类</title>
      <link href="2020/12/02/fen-bian-shi-ti-lei/"/>
      <url>2020/12/02/fen-bian-shi-ti-lei/</url>
      
        <content type="html"><![CDATA[<center style="font-size:25px;font-weight:bold">Bean的分辨</center><h4 id="POJO-Plain-Old-Java-Object"><a href="#POJO-Plain-Old-Java-Object" class="headerlink" title="POJO(Plain Old Java Object)"></a>POJO(Plain Old Java Object)</h4><p>pojo是DO/DTO/BO/VO的统称，禁止命名成 xxxPOJO</p><ul><li>DO(Data Object):**与数据库表结构一一对应，通过DAO层向上传输数据源对象,**用来和单表一一对应的实体类。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或者Manager向外传输的对象，<strong>比如Controller的入参xxxReqDTO,Service层的出参 xxxRespDTO</strong></li><li>BO（Businese Object):业务对象。由Service层输出的封装业务逻辑对象。</li><li>AO（Application Object):应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，服务都不高</li><li>VO（View Object):显示层对象，<strong>通常是Web向模板渲染引擎层传输的对象</strong></li><li>POJO(Plain Ordinary Java Object):POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等</li><li>PO(Persistant Object)可以看成是与数据库中的表相映射的java对象。比如PO对应数据表中的某一条记录，多个记录可以用PO的集合，PO应该不包含任何对数据库的操作。，由get/set/序列化组成。</li><li>Query:数据查询对象，各层接受上层的查询请求。注意超过两个参数的查询封装，禁止使用Map类来传输。</li></ul><p><strong><img src="/2020/12/02/fen-bian-shi-ti-lei/1736f3263e8988ba" class="" title="img"></strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Bean </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Redis</title>
      <link href="2020/12/01/learning-redis/"/>
      <url>2020/12/01/learning-redis/</url>
      
        <content type="html"><![CDATA[<center style="font-weight:bold;font-size:25px">Redis/MySQL</center><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>NoSQL, NOt only SQL, 高并发、海量数据存储解决方案。Redis、MongoDB等内存数据库。</p><p>Redis是完全开源的，用ANSI C编写的一个高性能的key-value数据库。</p><p>三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据存储到硬盘上，重启时可以使用。</li><li>Redis支持 list,set,zset,hash等数据结构。</li><li>Redis支持数据的备份，即<strong>master-slave模式的数据备份</strong>(不懂)</li><li>速度快、支持语言多、持久化、多种数据结构、主从复制以及高可用与分布式。</li></ul><p><escape><a id="more"></a><escape></escape></escape></p><h3 id="Redis的安装和使用"><a href="#Redis的安装和使用" class="headerlink" title="Redis的安装和使用"></a>Redis的安装和使用</h3><h5 id="Windows下安装："><a href="#Windows下安装：" class="headerlink" title="Windows下安装："></a>Windows下安装：</h5><p>下载地址：<a href="https://github.com/tporadowski/redis/releases">Redis下载链接</a></p><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>常规：进入redis安装目录，运行一下命令</p><blockquote><p>redis-server.exe redis.windows.conf    <strong>开启redis服务端</strong></p><p>redis-cli.exe -h 127.0.0.1 -p 6379 <strong>连接redis服务器并使用</strong></p></blockquote><p>如果出现  **# Creating Server TCP listening socket 127.0.0.1:6379: bind: No error ** 错误</p><p>则在命令行中运行</p><blockquote><p>redis-cli.exe<br>shutdown<br>exit</p></blockquote><p>配置文件中可以修改 Redis的连接密码   <strong>requirepass</strong> 字段  后面可以修改，修改密码要重启</p><blockquote><p>service redis restart</p></blockquote><blockquote><p>redis-cli.exe -h 127.0.0.1 -p 6379 -a  [password]</p><p>或者 登录时不指定密码    进入redis命令行后 运行 auth [password]</p></blockquote><h5 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h5><p><strong>string</strong>是redis最基本的类型，二进制安全，redis的string可以包含任何数据，比如jpg图片或者序列化的对象，最大能存储512MB。使用场景：缓存、秒杀、分布式锁、配置中心、对象序列化</p><p><strong>Hash</strong> 键值对集合，一个string类型的field 和value的映射标，特别适用于存储对象。 <strong><em>HMSET key member(key value)</em></strong>   Map类型</p><p><strong>List列表</strong> 简单的字符串列表，按照插入顺序排序。可以在头部或者尾部插入。lpush rpush lrange，可以存储2的32次方-1个元素。 消息队列、最新消息排行榜</p><p><strong>Set(集合)</strong> string类型的无序集合，通过hash标实现的，<del>添加，删除，查找的复杂度都是O（1）</del>**<em>sadd key member**</em>    共同好友，交集</p><p><strong>zset(有序集合）</strong> string类型元素的集合，不允许重复的成员。但每个元素都会关联一个double类型的分数，redis通过这个分数为集合中的成员从小到大排序 <strong><em>zadd key score member</em></strong>  排行榜，带权重的消息队列</p><h5 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h5><p>Redis支持多个数据库，每个数据库的数据是隔离的不能共享（单机）<br>Redis 默认支持16个数据库，配置文件(redis.windows.conf 的databases值 或者redis.conf(linux))可以支持更多，没有上限，可以用 select命令来更换数据库。默认连接0号数据库</p><p>以上都是基于单机redis的情况。集群情况下只有一个db0，不能使用select命令来切换数据库。</p><h5 id="Redis-keys命令"><a href="#Redis-keys命令" class="headerlink" title="Redis keys命令"></a>Redis keys命令</h5><table><thead><tr><th><center>命令及描述</center></th></tr></thead><tbody><tr><td>del key 删除Key</td></tr><tr><td>dump key 序列化给定Key，并给定序列化的值</td></tr><tr><td>exists key  是否存在key</td></tr><tr><td>expire key seconds  key 设置过期时间</td></tr><tr><td>keys pattern 查找符合给定模式pattern的key</td></tr><tr><td>type key 返回key所存储的值的类型</td></tr><tr><td>rename key newkey  修改Key的名称</td></tr></tbody></table><table><thead><tr><th>redis常用字符串命令 string相关</th></tr></thead><tbody><tr><td>set key value</td></tr><tr><td>get key</td></tr><tr><td>getrange key start end key中字符串的子字符串</td></tr><tr><td>incr key 将Key中存储的数字值加一</td></tr></tbody></table><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li>数据缓存（页面具体数据），页面缓存（商品内容，新闻内容）</li><li>分布式级群中架构的Session分离</li><li>应用排行榜，在线好友列表</li><li>任务队列，如抢购秒杀等。</li></ul><p>Redis在Java中的使用我将写成小demo上传到github上，后续补充链接。。。。</p><h3 id="MySQL的安装和使用"><a href="#MySQL的安装和使用" class="headerlink" title="MySQL的安装和使用"></a>MySQL的安装和使用</h3><p>MySQL的安装、使用步骤。（备忘）</p><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><p>待补充。。。。。</p><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>以下是安装5.7版本步骤</p><ol><li><p>运行以下命令更新YUM源。</p><pre><code>rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</code></pre></li><li><p>运行以下命令安装MySQL。</p><pre><code>yum -y install mysql-community-server</code></pre></li><li><p>运行以下命令查看MySQL版本号。</p><pre><code>mysql -V</code></pre><p>返回结果如下，表示MySQL安装成功。</p><pre><code>mysql  Ver 14.14 Distrib 5.7.31, for Linux (x86_64) using  EditLine wrapper</code></pre></li></ol><p>还有各种配置、安装版本不同等情况参考以下链接：</p><p><a href="https://help.aliyun.com/document_detail/116727.html?spm=a2c4g.11186623.6.1248.67a43c9dpU9UUr#title-np4-hic-947">阿里云手动部署MySQL数据库</a></p><p><a href="https://juejin.cn/post/6844903870053761037#heading-24">掘金CentOS安装MySQL详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫</title>
      <link href="2020/11/24/python-pa-chong/"/>
      <url>2020/11/24/python-pa-chong/</url>
      
        <content type="html"><![CDATA[<h4 id="正则表达式模块"><a href="#正则表达式模块" class="headerlink" title="正则表达式模块"></a>正则表达式模块</h4><p>re模块</p><p>引号中转义字符需要倒斜杠， 如果使用*<strong>原始字符串**<em>就很方便，python中可以</em></strong>在字符串的第一个引号之前加上r***，就可以将该字符串标记为原始字符串，不包括转移字符。</p><p><strong>re.compiler</strong> 编译方法，参数: arg1 正则表达式，返回一个 Regex对象</p><p><strong>Regex对象的search</strong> 方法查找传入的字符串，寻找该正则表达式的所有匹配，如果没有匹配，返回None,若找到search()方法将返回一个Match对象。(字符串中“第一次”匹配的文本)<br><strong>Match</strong> 对象 group()方法，返回被查找字符串中实际匹配的文本</p><p><strong>re.match</strong> 正则表达式方法， 参数：arg1 匹配规则（正则表达式），arg2 需要被过滤的内容，返回一个Match对象。</p><p>Match对象上调用 group(),返回匹配的结果。</p><a id="more"></a><h4 id="用正则表达式匹配更多模式"><a href="#用正则表达式匹配更多模式" class="headerlink" title="用正则表达式匹配更多模式"></a>用正则表达式匹配更多模式</h4><h5 id="利用括号分组"><a href="#利用括号分组" class="headerlink" title="利用括号分组"></a>利用括号分组</h5><p>组号一般从 1 开始标号，group()匹配对象方法中传入 整数1 或2，就可以取得匹配文本的不同部分。 向 group()方法中传入0或者 不传入参数，将返回整个匹配的文本。</p><p>groups()，一次可以获得所有的分组，返回值是一个 元组</p><h5 id="用管道匹配多个分组"><a href="#用管道匹配多个分组" class="headerlink" title="用管道匹配多个分组"></a>用管道匹配多个分组</h5><p>| 被称为 “管道”。希望匹配许多 正则表达式模式 中的一个时，就可以使用 （其实就是或）</p><p>这个只会返回 第一次出现的匹配文本，作为Match对象返回。</p><p>利用<strong>findall()**方法，可以找到 所有 匹配的地方。</strong>返回一组字符串**，包含所有被查找字符串的所有匹配。</p><p><strong>findall()</strong> 返回的不是一个Match对象，而是一个 <strong>字符串列表</strong></p><p>如果在正则表达式 中<strong>有分组</strong>，那么 findall将返回<strong>元组的列表</strong>（只会返回 分组内的内容 不在分组中的不反回）。  每一元组表示一个找到的匹配</p><img src="/2020/11/24/python-pa-chong/image-20201124235648626.png" class="" title="image-20201124235648626"><h5 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h5><p>Python的正则表达式默认是“贪心”的，这表示在<strong>有二义的情况下</strong>，会尽可能<strong>匹配最长的字符串</strong></p><h5 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h5><p>花括号的“非贪婪” 匹配是 <strong>匹配最短的字符串</strong>， 在 <strong><em>结束的花括号后面</em></strong> 跟着一个 问号。{n,m}？</p><p><strong><em>在方框内 [] (自己的字符分类),普通的正则表达式符号不会被解释， 即不需要加上 转义符号/</em></strong></p><p>通过在字符分类的左方括号后加上一个插入字符（^），就可以得到“非字符类”。</p><h5 id="用点-星匹配所有字符"><a href="#用点-星匹配所有字符" class="headerlink" title="用点-星匹配所有字符"></a>用点-星匹配所有字符</h5><p>.* 匹配任意文本  使用贪心模式：尽可能的匹配多的文本   若使用非贪心的模式  要在后面加个？问号</p><h5 id="用点-星匹配换行"><a href="#用点-星匹配换行" class="headerlink" title="用点-星匹配换行"></a>用点-星匹配换行</h5><p>通过传入<strong>re.DOTALL</strong>作为re.compile()的第二个参数，可以让<strong>句点字符匹配所有字符，包括换行字符。</strong></p><h5 id="不区分大小写的匹配"><a href="#不区分大小写的匹配" class="headerlink" title="不区分大小写的匹配"></a>不区分大小写的匹配</h5><p>要让正则表达式不区分大小写，可以向re.compile()传入<strong>re.IGNORECASE 或re.I</strong>，作为<strong>第二个参数</strong></p><h5 id="用sub-方法替换字符串"><a href="#用sub-方法替换字符串" class="headerlink" title="用sub()方法替换字符串"></a>用sub()方法替换字符串</h5><p>正则表达式可以找到  文本模式，也可以 用新的文本替换掉这些模式。</p><p>Regex对象的sub()方法需要传入两个参数。</p><blockquote><p>第一个参数是一个字符串，用于取代发现的匹配。</p><p>第二个参数是一个字符串，即正则表达式。</p><p>sub()方法返回替换完成后的字符串。</p></blockquote><h5 id="管理复杂的正则表达式"><a href="#管理复杂的正则表达式" class="headerlink" title="管理复杂的正则表达式"></a>管理复杂的正则表达式</h5><p>你可以告诉re.compile()，<strong>忽略正则表达式字符串中的空白符和注释</strong>，从而缓解这一点。</p><p>可以向re.compile()传入变量re.VERBOSE，作为第二个参数。   详细模式</p><p>正则表达式字符串  放多行，  每行用注释解释</p><p>使用  三重引号 创建多行字符串，才能多行注释。</p>]]></content>
      
      
      <categories>
          
          <category> Python爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2020/11/22/zheng-ze-biao-da-shi/"/>
      <url>2020/11/22/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li>\b匹配一个位置（前一个或后一个字符不全是\w）单词开始处或结束出</li><li>\d: 匹配数字</li><li>\w:匹配<strong>字母</strong>或<strong>数字</strong>或<strong>下划线</strong>或<strong>汉字</strong></li><li><em>: 元字符，指定 * *</em>前边的内容<strong>以可</strong>连续重复使用任意次**以使整个表达式得到匹配（可能0次）</li><li>+：元字符，和* 类似，重复一次或更多次</li><li>. (点):<u>匹配除了换行符以外的任意字符</u></li><li>^： 匹配字符串的开始</li><li>$: 匹配字符串的结束</li><li>\s : 匹配任意的空白符（空格、制表符tab，换行符，中文全角空格）</li><li>{number}代表重复{number}之前的内容number次</li></ol><a id="more"></a><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><ul><li>*重复0次或更多次</li><li>+ 重复一次或者更多次</li><li>？ 重复0次或一次</li><li>{n} 重复n次</li><li>{n,}重复n次或者更多次</li><li>{n,m} 重复n 到m次</li></ul><h3 id="字符类（匹配自己规定的字符范围）"><a href="#字符类（匹配自己规定的字符范围）" class="headerlink" title="字符类（匹配自己规定的字符范围）"></a>字符类（匹配自己规定的字符范围）</h3><p>匹配没有预定义元字符的字符集合（比如我想查找 元音字母 aeiou）</p><p>可以用方括号 列出他们 如：[aeiou]  [.?!]<u>匹配标点符号</u><br>[0-9]  [a-z0-9A-Z]</p><h3 id="分支条件（或者情况-）"><a href="#分支条件（或者情况-）" class="headerlink" title="分支条件（或者情况 |）"></a>分支条件（或者情况 |）</h3><p>如果<strong>满足其中任意一种规则</strong>都应该当成匹配，具体方法使用 <strong>|**把</strong>不同的规则**分开</p><p>从左到右判断，如果满足了某个分支的话，就不会再去管其他的条件了。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>字符后加 + * ?等都是重复单个字符，如何重复多个字符？ <strong>可以用小括号来指定<em>子表达式（分组）</em></strong>，然后就可以指定这个子表达式的重复次数了。</p><blockquote><p>(\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个<strong>分组</strong>)重复3次，最后再加上一个一到三位的数字(\d{1,3})。</p></blockquote><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>有时需要查找<strong>不属于</strong> 某个能简单定义的字符类的字符。比如 <strong>除数字意外的，其他任意字符</strong></p><p>常用的反义代码：</p><ul><li>\W :匹配任意不是 <strong>字母、数字、汉字、下划线</strong>的字符</li><li>\S: 匹配任意<strong>不是空白符</strong>的字符</li><li>\D：匹配任意<strong>非数字</strong>的字符</li><li>\B： 匹配<strong>不是单词开头或者结束</strong>的位置</li><li>[^x] : 匹配<strong>除了x以外</strong>的任意字符</li><li>[^aeiou] ：匹配<strong>除了aeiou这几个字母以外</strong> 的任意字符</li></ul><blockquote><p>\S+匹配不包含空白符的字符串。</p><p>&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串。</p></blockquote><h3 id="向后引用"><a href="#向后引用" class="headerlink" title="向后引用"></a>向后引用</h3><p><em>向后引用</em> 用于<strong><em>重复搜索_前面某个分组_匹配的文本</em></strong></p><blockquote><p>\b(\w+)\b\s+\1\b可以用来匹配_重复的单词_，像<em>go go</em>, 或者<em>kitty kitty</em>。这个表达式首先是*<strong>一个单词**<em>，也就是</em></strong>单词开始处和结束处之间的多于一个的字母或数字*<strong>(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是**<em>1个或几个空白符</em></strong>(\s+)，最后是**<em>分组1中捕获的内容**</em>（也就是前面匹配的那个单词）(\1)。</p></blockquote><p>使用**<em>小括号**</em> 指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>（分组捕获的内容）可以在表达式或者其他程序中作进一步的处理（如前面匹配后，后面利用前面匹配过得文本，通过组号访问并利用它重复匹配），每个分组会自动拥有一个<strong>组号</strong></p><p>可以自己指定子表达式的 <strong>组名</strong>  语法： (?<word>\w+) 这样就可以把\w+的组名指定为Word了，就是将尖括号或者单引号中的单词定义未组名</word></p><blockquote><table><thead><tr><th>(exp)</th><th>匹配exp,并捕获文本到自动命名的组里</th></tr></thead><tbody><tr><td>(?<name>exp)</name></td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr></tbody></table></blockquote><h3 id="零宽断言-（断言：用来声明一个应该为真的事实。）"><a href="#零宽断言-（断言：用来声明一个应该为真的事实。）" class="headerlink" title="零宽断言 （断言：用来声明一个应该为真的事实。）"></a>零宽断言 （断言：用来声明一个应该为真的事实。）</h3><p>以后继续。。。。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> 模式识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c/c++堆栈.md</title>
      <link href="2020/11/19/c-c-dui-zhan-md/"/>
      <url>2020/11/19/c-c-dui-zhan-md/</url>
      
        <content type="html"><![CDATA[<h3 id="C-创建对象："><a href="#C-创建对象：" class="headerlink" title="C++创建对象："></a>C++创建对象：</h3><ol><li><p><code>Object obj;</code>实例化方法 在栈中分配内存  </p></li><li><p><code>Object* object =new Object();</code>动态分配内存</p></li></ol><h3 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h3><blockquote><p>new必须delete删除 不用new系统会自动回收</p></blockquote><blockquote><p>new 建造一个有对象，并调用对象的构造函数初始化对象：第一步申请内存，第二步调用构造函数初始化对象，第三步返回指针所指向对象的类型和地址</p></blockquote><blockquote><p>delete：首先调用析构函数，然后销毁堆内存</p></blockquote><blockquote><p>对于非内部数据类型的对象而言，仅用malloc/free无法满足动态对象的要求。</p></blockquote><blockquote><p>free对象无法执行析构函数</p></blockquote><blockquote><p>new能够按照变量类型自动地分配所需空间长度，不必使用宏sizeof</p></blockquote><blockquote><p>new 能够返回正确的指针类型</p></blockquote><blockquote><p>new创建对象数组，只能使用对象的无参数构造函数</p></blockquote><blockquote><p>malloc函数本身并不识别要申请的内存是什么类型，只关心内存的总字节数</p></blockquote><a id="more"></a><h3 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h3><p>堆由开发人员分配和释放，若开发人员不释放，程序结束时由OS回收，堆内存的生长方向是</p><p>由低到高。堆 是动态存储区，程序运行时分配 malloc new都是堆上操作</p><h3 id="栈简介"><a href="#栈简介" class="headerlink" title="栈简介"></a>栈简介</h3><p>栈：由操作系统自动分配释放，用于存放函数的参数值、局部变量等。</p><p>函数中定义的局部变量按照先后定义的顺序一次压入栈中。栈的内存地址生长方向由高到低，</p><p>所以 后定义的变量地址低于先定义的变量</p><h3 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h3><ul><li><p>管理方式不同：栈由操作系统自动分配释放，无需手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏。</p></li><li><p>空间大小不同：每个进程拥有的栈的大小远远小于堆的大小。理论上，程序员可以申请堆的大小为虚拟内存的大小。</p></li><li><p>生长方向不同：堆的生长方向 由低到高；栈的生长方向由高到低</p></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMjIyMjI1OTU0NjA5?x-oss-process=image/format,png" alt="栈图"></p><p> （<strong>EBP寄存器是用于访问堆栈中的数据的</strong>，它指向堆栈中间的某个位置（具体位置后文会具体讲解），<em>函数的参数地址比EBP的值高</em>，而<em>函数的局部变量地址比EBP的值低</em>，因此参数或局部变量总是通过EBP加减一定的偏移地址来访问的）</p><ul><li><p>分配方式不同：<strong>堆都是动态分配的，没有静态分配的堆</strong>。栈由两种分配方式：<strong>静态分配和动态分配。</strong></p></li><li><p><strong>静态分配</strong>是由操作系统完成，如 局部变量的分配。 <strong>动态分配</strong>是由 alloca函数进行分配，但是栈的动态分配是由操作系统进行释放，<strong>与堆不同</strong>。</p></li><li><p>存放内容不同：栈存放的内容，<em>函数返回地址、相关参数、局部变量和寄存器内容等</em>；堆中具体存放的内容是由<em>程序员来填充</em>的。</p></li><li><p>全局区：<strong>全局变量和静态变量的存储是放在一块的</strong>，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放</p></li><li><p>文字常量区：常量字符串放在这里，程序结束后由系统释放</p></li><li><p>程序代码区：存放函数体的二进制代码</p></li></ul><p><span class="github-emoji"><span>🦅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f985.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <span class="github-emoji"><span>🦁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f981.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/15/hello-world/"/>
      <url>2020/11/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初学者 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
